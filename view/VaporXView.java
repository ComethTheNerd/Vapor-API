/*	Vapor API Terms and Conditions
 *
 *  - You MAY NOT
 *  	- attempt to claim ownership of, or pass off the Vapor source code and materials as your own work unless:
 *
 *  		- used as constituent component in an Android application that you intend to release and/or profit from
 *
 *		- use or redistribute the Vapor source code and materials without explicit attribution to the owning parties
 *
 *  	- advertise Vapor in a misleading, inappropriate or offensive fashion
 *
 * - Indemnity
 * 		You agree to indemnify and hold harmless the authors of the Software and any contributors for any direct, indirect, 
 * 		incidental, or consequential third-party claims, actions or suits, as well as any related expenses, liabilities, damages, 
 * 		settlements or fees arising from your use or misuse of the Software, or a violation of any terms of this license.
 *  
 *  - DISCLAIMER OF WARRANTY
 *  	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, 
 *		WARRANTIES OF QUALITY, PERFORMANCE, NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
 *  
 *  - LIMITATIONS OF LIABILITY
 *  	YOU ASSUME ALL RISK ASSOCIATED WITH THE INSTALLATION AND USE OF THE SOFTWARE. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT 
 * 		HOLDERS OF THE SOFTWARE BE LIABLE FOR CLAIMS, DAMAGES OR OTHER LIABILITY ARISING FROM, OUT OF, OR IN CONNECTION WITH THE 
 *		SOFTWARE. LICENSE HOLDERS ARE SOLELY RESPONSIBLE FOR DETERMINING THE APPROPRIATENESS OF USE AND ASSUME ALL RISKS ASSOCIATED 
 *		WITH ITS USE, INCLUDING BUT NOT LIMITED TO THE RISKS OF PROGRAM ERRORS, DAMAGE TO EQUIPMENT, LOSS OF DATA OR SOFTWARE PROGRAMS, 
 *		OR UNAVAILABILITY OR INTERRUPTION OF OPERATIONS.
 *  
 *  Â© Darius Hodaei. License Version 1.1. Last Updated 30/06/2013.
*/

/*This file has been autogenerated by the Vapid Tool v1.0 @ 22/12/2012 22:43:05*/
package vapor.view;

import java.util.ArrayList;

import vapor.core.$;
import vapor.core.VaporX;
import vapor.os.VaporBundle;
import android.content.ClipData;
import android.content.Context;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.graphics.Point;
import android.graphics.Rect;
import android.graphics.drawable.Drawable;
import android.os.Handler;
import android.os.IBinder;
import android.os.Parcelable;
import android.util.SparseArray;
import android.view.ActionMode;
import android.view.ContextMenu;
import android.view.Display;
import android.view.DragEvent;
import android.view.KeyEvent;
import android.view.MotionEvent;
import android.view.TouchDelegate;
import android.view.View;
import android.view.View.AccessibilityDelegate;
import android.view.View.OnAttachStateChangeListener;
import android.view.View.OnFocusChangeListener;
import android.view.View.OnLayoutChangeListener;
import android.view.ViewGroup;
import android.view.ViewGroup.LayoutParams;
import android.view.ViewParent;
import android.view.ViewPropertyAnimator;
import android.view.ViewTreeObserver;
import android.view.accessibility.AccessibilityEvent;
import android.view.accessibility.AccessibilityNodeInfo;
import android.view.accessibility.AccessibilityNodeProvider;
import android.view.animation.Animation;
import android.view.inputmethod.EditorInfo;
import android.view.inputmethod.InputConnection;

/**
 * Fluent variadic Vapor companion to View, a class that represents the basic
 * building block for user interface components. A View occupies a rectangular
 * area on the screen and is responsible for drawing and event handling.
 * 
 * @author Darius H (darius@vapor-api.com)
 * @since 1.0
 * @param <T>
 *            A standard Android type derived from View
 * @param <X>
 *            A Vapor type derived from VaporView
 * @param <self>
 *            A recursively defined type that provides information for fluent
 *            method invocation
 */
public class VaporXView<T extends View, X extends VaporView<T, ?>, self extends VaporXView<T, X, self>>
		extends VaporX<X, self> {

	public VaporXView(Integer... ids) {
		for (int id : ids)
			addInt(id);
	}

	public VaporXView(T... views) {
		for (T view : views)
			members.add((X) $.vapor(view));
	}

	public VaporXView(X... vaporViews) {
		for (X vaporView : vaporViews)
			this.members.add(vaporView);
	}

	public VaporXView(VaporXView<T, X, ?>... vaporXViews) {

		for (VaporXView<T, X, ?> vaporXView : vaporXViews)
			for (X vaporView : vaporXView.members()) {
				addX(vaporView);
			}
	}

	public VaporXView(Object... viewItems) {
		add(viewItems);
	}

	/**
	 * Look for a child view with the given id. If this view has the given id,
	 * return this view.
	 * 
	 * @param id
	 *            The id to search for.
	 * @return The view that has the given id in the hierarchy or null
	 */
	@SuppressWarnings("unchecked")
	private final T load(int id) {
		return (T) ($.act().findViewById(id));
	} // COPIED IN VaporView

	private final self addInts(int... ids) {
		for (int id : ids)
			addInt(id);
		return (self) this;
	}

	private self addInt(int id) {
		members.add((X) $.vapor(load(id)));
		return (self) this;
	}

	private final self addTs(T... views) {
		for (T view : views)
			addT(view);
		return (self) this;
	}

	private final self addT(T view) {
		members.add((X) $.vapor(view));
		return (self) this;
	}

	private final self addXs(X... vaporViews) {
		for (X vaporView : vaporViews)
			addX(vaporView);
		return (self) this;
	}

	private final self addX(X vaporView) {
		members.add(vaporView);
		return (self) this;
	}

	private final self addSelf(self... vaporXViews) {
		for (self vaporXView : vaporXViews)
			addSelf(vaporXView);
		return (self) this;
	}

	private final self addSelfs(self vaporXView) {
		for (X vaporView : vaporXView.members())
			addX(vaporView);
		return (self) this;
	}

	protected final self add(Object... mixedSelectors) {

		for (Object selector : mixedSelectors) {
			try {
				// first we try to cast to X
				members.add((X) selector);
				continue;
			} catch (ClassCastException e1) {
				try {
					// first we try to cast to T
					members.add((X) $.vapor((T) selector));
					continue;
				} catch (ClassCastException e2) {
					// if that fails
					try {
						// we then try to cast to Integer
						addInt((Integer) selector);
						continue;
						// Intentionally let this through an exception if it
						// fails

					} catch (ClassCastException e3) {

						// As a last resort cast it to 'self'
						members.addAll(((self) selector).members());
						/*
						 * // if that fails we have no choice but to throw an //
						 * Exception throw new Exception(
						 * "Item is not an instance of an expected type: " +
						 * item.getClass().getSimpleName());
						 */
					}

				}

			}

		}
		return (self) this;
	}

	// VAPOR X
	// ONLY-------------------------------------------------------------------------

	// -------------------------------------------------------------------------VAPOR
	// X ONLY
	/**
	 * Returns the index of the VaporView with the given id in the underlying
	 * VaporView collection
	 * 
	 * @param id
	 *            The VaporView id to search for
	 * @return the index of the VaporView with the given id in the underlying
	 *         VaporView collection, or -1 if not found
	 */
	public int index(int id) {
		for (int index = 0; index < this.members.size(); ++index)
			if (members.get(index).id() == id)
				return index;

		// not found
		return -1;
	}

	/**
	 * Returns the VaporView with the given id in the underlying VaporView
	 * collection
	 * 
	 * @param id
	 *            The id that pertains to the VaporView that should be returned
	 * @return The VaporView with the given id in the underlying VaporView
	 *         collection, or null if not found
	 */
	public X member(int id) {

		int index = index(id);

		if (index != -1)
			return members.get(index);
		else
			return null;
	}

	/**
	 * Returns an integer denoting the type of container in which this View is
	 * placed
	 * 
	 * @return an integer denoting the type of container in which this View is
	 *         placed
	 */
	public final ArrayList<Integer> containedBy() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).containedBy());
		return _returns;
	}

	/**
	 * Makes the VaporTextView exactly this many pixels tall. You could do the
	 * same thing by specifying this number in the LayoutParams. Note that
	 * setting this value overrides any other (minimum / maximum) number of
	 * lines or height setting.
	 * 
	 * @param pixels
	 * @return self
	 */
	public self height(int pixels) {
		for (X vaporView : members)
			vaporView.height(pixels);
		return (self) this;

	}

	/**
	 * Makes the TextView exactly this many pixels wide. You could do the same
	 * thing by specifying this number in the LayoutParams.
	 * 
	 * @param pixels
	 * @return self
	 */
	public self width(int pixels) {
		for (X vaporView : members)
			vaporView.width(pixels);
		return (self) this;

	}

	/**
	 * Sets the size of this view
	 * 
	 * @param width
	 *            The width of the view
	 * @param height
	 *            The height of the view
	 * @return self
	 */
	public self size(int width, int height) {
		for (X vaporView : members)
			vaporView.size(width, height);
		return (self) this;
	}

	/**
	 * Performs a bounce animation using the default bounce settings
	 * 
	 * @return self
	 */
	public self bounce() {
		for (X vaporView : members)
			vaporView.bounce(null);
		return (self) this;
	}

	/**
	 * Performs a bounce animation using the supplied bounce settings
	 * 
	 * @return self
	 */
	public self bounce(VaporBundle options) {
		for (X vaporView : members)
			vaporView.bounce(options);
		return (self) this;
	}

	/**
	 * Performs a fade animation using the default fade settings
	 * 
	 * @return self
	 */
	public self fade() {
		for (X vaporView : members)
			vaporView.fade(null);
		return (self) this;
	}

	/**
	 * Performs a fade animation using the supplied fade settings
	 * 
	 * @return self
	 */
	public self fade(VaporBundle options) {
		for (X vaporView : members)
			vaporView.fade(options);
		return (self) this;
	}

	/**
	 * Performs a flip animation using the default flip settings
	 * 
	 * @return self
	 */
	public self flip() {
		for (X vaporView : members)
			vaporView.flip(null);
		return (self) this;
	}

	/**
	 * Performs a flip animation using the supplied flip settings
	 * 
	 * @return self
	 */
	public self flip(VaporBundle options) {
		for (X vaporView : members)
			vaporView.flip(options);
		return (self) this;
	}

	/**
	 * Performs a fade in animation using the default fade in settings
	 * 
	 * @return self
	 */
	public self fadeIn() {
		for (X vaporView : members)
			vaporView.fadeIn(null);
		return (self) this;
	}

	/**
	 * Performs a fade in animation using the supplied fade in settings
	 * 
	 * @return self
	 */
	public self fadeIn(VaporBundle options) {
		for (X vaporView : members)
			vaporView.fadeIn(options);
		return (self) this;
	}

	/**
	 * Performs a fade out animation using the default fade out settings
	 * 
	 * @return self
	 */
	public self fadeOut() {
		for (X vaporView : members)
			vaporView.fadeOut(null);
		return (self) this;
	}

	/**
	 * Performs a fade out animation using the supplied fade out settings
	 * 
	 * @return self
	 */
	public self fadeOut(VaporBundle options) {
		for (X vaporView : members)
			vaporView.fadeOut(options);
		return (self) this;
	}

	/**
	 * Performs a hide animation using the supplied hide settings
	 * 
	 * @return self
	 */
	public self hide() {
		for (X vaporView : members)
			vaporView.hide(null);
		return (self) this;
	}

	/**
	 * Performs a hide animation using the supplied hide settings
	 * 
	 * @return self
	 */
	public self hide(VaporBundle options) {
		for (X vaporView : members)
			vaporView.hide(options);
		return (self) this;
	}

	/**
	 * Performs a pulse animation using the default pulse settings
	 * 
	 * @return self
	 */
	public self pulse() {
		for (X vaporView : members)
			vaporView.pulse(null);
		return (self) this;
	}

	/**
	 * Performs a pulse animation using the supplied pulse settings
	 * 
	 * @return self
	 */
	public self pulse(VaporBundle options) {
		for (X vaporView : members)
			vaporView.pulse(options);
		return (self) this;
	}

	/**
	 * Performs a resize animation using the default resize settings
	 * 
	 * @return self
	 */
	public self resize() {
		for (X vaporView : members)
			vaporView.resize(null);
		return (self) this;
	}

	/**
	 * Performs a resize animation using the supplied resize settings
	 * 
	 * @return self
	 */
	public self resize(VaporBundle options) {
		for (X vaporView : members)
			vaporView.resize(options);
		return (self) this;
	}

	/**
	 * Performs a shake animation using the default shake settings
	 * 
	 * @return self
	 */
	public self shake() {
		for (X vaporView : members)
			vaporView.shake(null);
		return (self) this;
	}

	/**
	 * Performs a shake animation using the supplied shake settings
	 * 
	 * @return self
	 */
	public self shake(VaporBundle options) {
		for (X vaporView : members)
			vaporView.shake(options);
		return (self) this;
	}

	/**
	 * Performs a show animation using the default show settings
	 * 
	 * @return self
	 */
	public self show() {
		for (X vaporView : members)
			vaporView.show(null);
		return (self) this;
	}

	/**
	 * Performs a show animation using the supplied show settings
	 * 
	 * @return self
	 */
	public self show(VaporBundle options) {
		for (X vaporView : members)
			vaporView.show(options);
		return (self) this;
	}

	/**
	 * Performs a slide animation using the default slide settings
	 * 
	 * @return self
	 */
	public self slide() {
		for (X vaporView : members)
			vaporView.slide(null);
		return (self) this;
	}

	/**
	 * Performs a slide animation using the supplied slide settings
	 * 
	 * @return self
	 */
	public self slide(VaporBundle options) {
		for (X vaporView : members)
			vaporView.slide(options);
		return (self) this;
	}

	/**
	 * Performs a slide animation in the given direction, using the supplied
	 * slide settings
	 * 
	 * @param direction
	 *            The direction in which to slide
	 * @param options
	 *            Custom settings for the animation
	 * @return self
	 */
	protected self slide(String direction, VaporBundle options) {
		for (X vaporView : members)
			vaporView.slide(direction, options);
		return (self) this;
	}

	/**
	 * Performs a slide up animation using the default slide up settings
	 * 
	 * @return self
	 */
	public self slideUp() {
		for (X vaporView : members)
			vaporView.slideUp(null);
		return (self) this;
	}

	/**
	 * Performs a slide up animation using the supplied slide up settings
	 * 
	 * @return self
	 */
	public self slideUp(VaporBundle options) {
		for (X vaporView : members)
			vaporView.slideUp(options);
		return (self) this;
	}

	/**
	 * Performs a slide left animation using the default slide left settings
	 * 
	 * @return self
	 */
	public self slideLeft() {
		for (X vaporView : members)
			vaporView.slideLeft(null);
		return (self) this;
	}

	/**
	 * Performs a slide left animation using the supplied slide left settings
	 * 
	 * @return self
	 */
	public self slideLeft(VaporBundle options) {
		for (X vaporView : members)
			vaporView.slideLeft(options);
		return (self) this;
	}

	/**
	 * Performs a slide right animation using the default slide right settings
	 * 
	 * @return self
	 */
	public self slideRight() {
		for (X vaporView : members)
			vaporView.slideRight(null);
		return (self) this;
	}

	/**
	 * Performs a slide right animation using the supplied slide right settings
	 * 
	 * @return self
	 */
	public self slideRight(VaporBundle options) {
		for (X vaporView : members)
			vaporView.slideRight(options);
		return (self) this;
	}

	/**
	 * Performs a slide down animation using the default slide down settings
	 * 
	 * @return self
	 */
	public self slideDown() {
		for (X vaporView : members)
			vaporView.slideDown(null);
		return (self) this;
	}

	/**
	 * Performs a slide down animation using the supplied slide down settings
	 * 
	 * @return self
	 */
	public self slideDown(VaporBundle options) {
		for (X vaporView : members)
			vaporView.slideDown(options);
		return (self) this;
	}

	/**
	 * Indicates whether this view is attached to a hardware accelerated window
	 * or not.
	 * 
	 * @return True if the view is attached to a window and the window is
	 *         hardware accelerated; false in any other case.
	 */
	public ArrayList<Boolean> accelerated() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).accelerated());
		return _returns;
	}

	/**
	 * Performs the specified accessibility action on the view. For possible
	 * accessibility actions look at AccessibilityNodeInfo.
	 * 
	 * @param action
	 *            The action to perform.
	 * @param arguments
	 *            Optional action arguments.
	 * @return Whether the action was performed.
	 */
	public ArrayList<Boolean> access(int action, VaporBundle arguments) {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).access(action, arguments));
		return _returns;
	}

	/**
	 * Adds the children of a given View for accessibility. Since some Views are
	 * not important for accessibility the children for accessibility are not
	 * necessarily direct children of the view, rather they are the first level
	 * of descendants important for accessibility.
	 * 
	 * @param children
	 * @return The list of children for accessibility.
	 */
	public self accessChildren(
			ArrayList<VaporView<? extends View, ?>> childrenForAccessibility) {
		for (X vaporView : members)
			vaporView.accessChildren(childrenForAccessibility);
		return (self) this;

	}

	/**
	 * Start an action mode.
	 * 
	 * @param callback
	 *            Callback that will control the lifecycle of the action mode
	 * @return self
	 */
	public ArrayList<ActionMode> action(ActionMode.Callback actionModeCallback) {
		int _size = this.members.size();
		ArrayList<ActionMode> _returns = new ArrayList<ActionMode>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).action(actionModeCallback));
		return _returns;
	}

	/**
	 * Indicates the activation state of this view.
	 * 
	 * @return true if the view is activated, false otherwise
	 */
	public ArrayList<Boolean> activated() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).activated());
		return _returns;
	}

	/**
	 * Changes the activated state of this view.
	 * 
	 * @param activated
	 *            true if the view must be activated, false otherwise
	 * @return self
	 */
	public self activated(boolean activated) {
		for (X vaporView : members)
			vaporView.activated(activated);
		return (self) this;

	}

	/**
	 * Aligns the bottom edge of a View with the given View
	 * 
	 * @param alignWith
	 *            The VaporView to align bottom with
	 * @return self
	 */
	public self alignBottom(VaporView<? extends View, ?> alignWith) {
		return bottom(alignWith.bottom());
	}

	/**
	 * Aligns the left edge of a VaporView with the given VaporView
	 * 
	 * @param alignWith
	 *            The VaporView to align left with
	 * @return self
	 */
	public self alignLeft(VaporView<? extends View, ?> alignWith) {
		return left(alignWith.left());
	}

	/**
	 * Aligns the right edge of a VaporView with the given VaporView
	 * 
	 * @param alignWith
	 *            The VaporView to align right with
	 * @return self
	 */
	public self alignRight(VaporView<? extends View, ?> alignWith) {
		return right(alignWith.right());
	}

	/**
	 * Aligns the top edge of a VaporView with the given VaporView
	 * 
	 * @param alignWith
	 *            The VaporView to align top with
	 * @return self
	 */
	public self alignTop(VaporView<? extends View, ?> alignWith) {
		return top(alignWith.top());
	}

	/**
	 * The opacity of the view from 0 to 1, where 0 means the view is completely
	 * transparent and 1 means the view is completely opaque
	 * 
	 * @return The opacity of the view.
	 */
	public ArrayList<Float> alpha() {
		int _size = this.members.size();
		ArrayList<Float> _returns = new ArrayList<Float>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).alpha());
		return _returns;
	}

	/**
	 * Sets the opacity of the view.
	 * 
	 * @param alpha
	 *            The opacity of the view.
	 * @return self
	 */
	public self alpha(float alpha) {
		for (X vaporView : members)
			vaporView.alpha(alpha);
		return (self) this;

	}

	/**
	 * This method returns a ViewPropertyAnimator object, which can be used to
	 * animate specific properties on this View.
	 * 
	 * @return ViewPropertyAnimator The ViewPropertyAnimator associated with
	 *         this View.
	 */
	public ArrayList<ViewPropertyAnimator> animate() {
		int _size = this.members.size();
		ArrayList<ViewPropertyAnimator> _returns = new ArrayList<ViewPropertyAnimator>(
				_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).animate());
		return _returns;
	}

	/**
	 * Get the animation currently associated with this view.
	 * 
	 * @return The animation that is currently playing or scheduled to play for
	 *         this view.
	 */
	public ArrayList<Animation> anim() {
		int _size = this.members.size();
		ArrayList<Animation> _returns = new ArrayList<Animation>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).anim());
		return _returns;
	}

	/**
	 * Sets the next animation to play for this view.
	 * 
	 * @param animation
	 *            The next animation, or null.
	 * @return self
	 */
	public self anim(Animation animation) {
		for (X vaporView : members)
			vaporView.anim(animation);
		return (self) this;

	}

	/**
	 * Convenience method for sending a TYPE_ANNOUNCEMENT AccessibilityEvent to
	 * make an announcement which is related to some sort of a context change
	 * for which none of the events representing UI transitions is a good fit.
	 * 
	 * @param text
	 *            The announcement text.
	 * @return self
	 */
	public self accessAnnounce(CharSequence text) {
		for (X vaporView : members)
			vaporView.accessAnnounce(text);
		return (self) this;

	}

	/**
	 * Return the offset of the widget's text baseline from the widget's top
	 * boundary.
	 * 
	 * @return the offset of the baseline within the widget's bounds or -1 if
	 *         baseline alignment is not supported
	 */
	public ArrayList<Integer> baseline() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).baseline());
		return _returns;
	}

	/**
	 * Gets the background drawable.
	 * 
	 * @return The drawable used as the background for this view, if any.
	 */
	public ArrayList<Drawable> bg() {
		int _size = this.members.size();
		ArrayList<Drawable> _returns = new ArrayList<Drawable>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).bg());
		return _returns;
	}

	/**
	 * Set the background to a given Drawable, or remove the background.
	 * 
	 * @param background
	 *            The Drawable to use as the background, or null to remove the
	 *            background
	 * @return self
	 */
	public self bg(Drawable background) {
		for (X vaporView : members)
			vaporView.bg(background);
		return (self) this;

	}

	/**
	 * Set the background to a given resource.
	 * 
	 * @param resId
	 *            The identifier of the resource.
	 * @return self
	 */
	public self bg(int resId) {
		for (X vaporView : members)
			vaporView.bg(resId);
		return (self) this;

	}

	/**
	 * Sets the background color for this view.
	 * 
	 * @param color
	 *            the color of the background
	 * @return self
	 */
	public self bgColor(int color) {
		for (X vaporView : members)
			vaporView.bgColor(color);
		return (self) this;

	}

	/**
	 * Bottom position of this view relative to its parent.
	 * 
	 * @return The bottom of this view, in pixels.
	 */
	public final ArrayList<Integer> bottom() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).bottom());
		return _returns;
	}

	/**
	 * Sets the bottom position of this view relative to its parent.
	 * 
	 * @param bottom
	 *            The bottom of this view, in pixels.
	 * @return self
	 */
	public self bottom(int bottom) {
		for (X vaporView : members)
			vaporView.bottom(bottom);
		return (self) this;

	}

	/**
	 * Calling this method is equivalent to calling buildDrawCache(false).
	 * 
	 * @return self
	 */
	public self buildDrawCache() {
		for (X vaporView : members)
			vaporView.buildDrawCache();
		return (self) this;

	}

	/**
	 * Forces the drawing cache to be built if the drawing cache is invalid.
	 * 
	 * @param autoScale
	 * @return self
	 */
	public self buildDrawCache(boolean autoScale) {
		for (X vaporView : members)
			vaporView.buildDrawCache(autoScale);
		return (self) this;

	}

	/**
	 * Forces this view's layer to be created and this view to be rendered into
	 * its layer.
	 * 
	 * @throws IllegalStateException
	 *             If this view is not attached to a window
	 * @return self
	 */
	public self buildLayer() {
		for (X vaporView : members)
			vaporView.buildLayer();
		return (self) this;

	}

	/**
	 * Cancels a pending long press.
	 * 
	 * @return self
	 */
	public self cancelLongPress() {
		for (X vaporView : members)
			vaporView.cancelLongPress();
		return (self) this;

	}

	/**
	 * Check if this view can be scrolled horizontally in a certain direction.
	 * 
	 * @param direction
	 *            Negative to check scrolling left, positive to check scrolling
	 *            right.
	 * @return true if this view can be scrolled in the specified direction,
	 *         false otherwise.
	 */
	public ArrayList<Boolean> xScrollable(int direction) {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).xScrollable(direction));
		return _returns;
	}

	/**
	 * Check if this view can be scrolled vertically in a certain direction.
	 * 
	 * @param direction
	 *            Negative to check scrolling up, positive to check scrolling
	 *            down.
	 * @return true if this view can be scrolled in the specified direction,
	 *         false otherwise.
	 */
	public ArrayList<Boolean> yScrollable(int direction) {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).yScrollable(direction));
		return _returns;
	}

	/**
	 * Directly call any attached OnClickListener. Unlike click(), this only
	 * calls the listener, and does not do any associated clicking actions like
	 * reporting an accessibility event.
	 * 
	 * @return True there was an assigned OnClickListener that was called, false
	 *         otherwise is returned.
	 */
	public ArrayList<Boolean> click() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).click());
		return _returns;
	}

	/**
	 * Call this view's $click listener, if it is defined. Performs all normal
	 * actions associated with clicking: reporting accessibility event, playing
	 * a sound, etc.
	 * 
	 * @return True there was an assigned $click listener that was called, false
	 *         otherwise is returned.
	 */
	public ArrayList<Boolean> clickExt() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).clickExt());
		return _returns;
	}

	/**
	 * Enables or disables click events for this view.
	 * 
	 * @param clickable
	 *            true to make the view clickable, false otherwise
	 * @return self
	 */
	public self clickable(boolean clickable) {
		for (X vaporView : members)
			vaporView.clickable(clickable);
		return (self) this;

	}

	/**
	 * Register a callback to be invoked when this view is clicked.
	 * 
	 * @param clickListener
	 *            The callback that will run
	 * @return self
	 */
	public self click(vapor.listeners.view.$click clickListener) {
		for (X vaporView : members)
			vaporView.click(clickListener);
		return (self) this;

	}

	/**
	 * Center this view both horizontally and vertically in its parent view
	 * 
	 * @return self
	 */
	public self center() {
		for (X vaporView : members)
			vaporView.center();
		return (self) this;
	}

	/**
	 * Center this view vertically in its parent view
	 * 
	 * @return self
	 */
	public self centerY() {
		for (X vaporView : members)
			vaporView.centerY();
		return (self) this;
	}

	/**
	 * Center this view horizontally in its parent view
	 * 
	 * @return self
	 */
	public self centerX() {
		for (X vaporView : members)
			vaporView.centerX();
		return (self) this;
	}

	/**
	 * Cancels any animations for this view.
	 * 
	 * @return self
	 */
	public self cancelAnim() {
		for (X vaporView : members)
			vaporView.cancelAnim();
		return (self) this;

	}

	/**
	 * Called when this view wants to give up focus.
	 * 
	 * @return self
	 */
	public self cancelFocus() {
		for (X vaporView : members)
			vaporView.cancelFocus();
		return (self) this;

	}

	/**
	 * Indicates whether this view reacts to click events or not.
	 * 
	 * @return true if the view is clickable, false otherwise
	 */
	public ArrayList<Boolean> clickable() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).clickable());
		return _returns;
	}

	/**
	 * Return whether this view has an attached OnClickListener.
	 * 
	 * @return true if there is a listener, false if there is none.
	 */
	public ArrayList<Boolean> clickListening() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).clickListening());
		return _returns;
	}

	/**
	 * Merge two states as returned by measuredState().
	 * 
	 * @param currentState
	 *            The current state as returned from a view or the result of
	 *            combining multiple views.
	 * @param newState
	 *            The new view state to combine.
	 * @return Returns a new integer reflecting the combination of the two
	 *         states.
	 */
	public static int combine(int currentState, int newState) {
		return View.combineMeasuredStates(currentState, newState);
	}

	/**
	 * Fluent equivalent Vapor method for invoking
	 * onCreateInputConnection(EditorInfo), that creates a new InputConnection
	 * for an InputMethod to interact with the view.
	 * 
	 * @param outAttrs
	 *            Fill in with attribute information about the connection.
	 * @return self
	 */
	public ArrayList<InputConnection> conn(EditorInfo outAttrs) {
		int _size = this.members.size();
		ArrayList<InputConnection> _returns = new ArrayList<InputConnection>(
				_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).conn(outAttrs));
		return _returns;
	}

	/**
	 * Returns the context the view is running in, through which it can access
	 * the current theme, resources, etc.
	 * 
	 * @return The view's Context.
	 */
	public ArrayList<Context> context() {
		int _size = this.members.size();
		ArrayList<Context> _returns = new ArrayList<Context>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).context());
		return _returns;
	}

	/**
	 * Indicates whether this duplicates its drawable state from its parent.
	 * 
	 * @return True if this view's drawable state is duplicated from the parent,
	 *         false otherwise
	 */
	public ArrayList<Boolean> copyParent() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).copyParent());
		return _returns;
	}

	/**
	 * Enables or disables the duplication of the parent's state into this view.
	 * 
	 * @param enabled
	 *            True to enable duplication of the parent's drawable state,
	 *            false to disable it.
	 * @return self
	 */
	public self copyParent(boolean enabled) {
		for (X vaporView : members)
			vaporView.copyParent(enabled);
		return (self) this;

	}

	/**
	 * Utility to return a default size.
	 * 
	 * @param size
	 *            Default size for this view
	 * @param measureSpec
	 *            Constraints imposed by the parent
	 * @return The size this view should be.
	 */
	public static int defSize(int size, int measureSpec) {
		return View.getDefaultSize(size, measureSpec);
	}

	/**
	 * Gets the View description.
	 * 
	 * @return The content description.
	 */
	public ArrayList<CharSequence> describe() {
		int _size = this.members.size();
		ArrayList<CharSequence> _returns = new ArrayList<CharSequence>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).describe());
		return _returns;
	}

	/**
	 * Sets the description.
	 * 
	 * @param contentDescription
	 *            The content description.
	 * @return self
	 */
	public self describe(CharSequence contentDescription) {
		for (X vaporView : members)
			vaporView.describe(contentDescription);
		return (self) this;

	}

	/**
	 * True if this view has changed since the last time being drawn.
	 * 
	 * @return The dirty state of this view.
	 */
	public ArrayList<Boolean> dirty() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).dirty());
		return _returns;
	}

	/**
	 * Dispatch a notification about a resource configuration change down the
	 * view hierarchy.
	 * 
	 * @param newConfig
	 * @return self
	 */
	public self dispatchConfig(Configuration newConfig) {
		for (X vaporView : members)
			vaporView.dispatchConfig(newConfig);
		return (self) this;

	}

	/**
	 * Detects if this View is enabled and has a drag event listener. If both
	 * are true, then it calls the drag event listener with the DragEvent it
	 * received. If the drag event listener returns true, then dispatchDrag()
	 * returns true.
	 * 
	 * @param dragEvent
	 *            the drag event
	 * @return If the drag event listener returns true, then dispatchDrag()
	 *         returns true.
	 */
	public ArrayList<Boolean> dispatchDrag(DragEvent dragEvent) {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).dispatchDrag(dragEvent));
		return _returns;
	}

	/**
	 * Dispatch a hint about whether this view is displayed.
	 * 
	 * @param displayHint
	 *            A hint about whether or not this view is displayed: VISIBLE or
	 *            INVISIBLE.
	 * @return self True if the event was handled by the view, false otherwise.
	 */
	public self dispatchHint(int displayHint) {
		for (X vaporView : members)
			vaporView.dispatchHint(displayHint);
		return (self) this;

	}

	/**
	 * Dispatches a key shortcut event.
	 * 
	 * @param keyEvent
	 *            The key event to be dispatched.
	 * @return
	 */
	public ArrayList<Boolean> dispatchHotKey(KeyEvent keyEvent) {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).dispatchHotKey(keyEvent));
		return _returns;
	}

	/**
	 * Dispatch a generic motion event.
	 * 
	 * @param genericMotionEvent
	 *            The motion event to be dispatched.
	 * @return True if the event was handled by the view, false otherwise.
	 */
	public ArrayList<Boolean> dispatchMotion(MotionEvent genericMotionEvent) {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).dispatchMotion(
					genericMotionEvent));
		return _returns;
	}

	/**
	 * Dispatches an AccessibilityEvent to the View first and then to its
	 * children for adding their text content to the event.
	 * 
	 * @param accessibilityEvent
	 *            true populates to its children for adding their text content
	 *            to the event.
	 * @return True if the event population was completed.
	 */
	public ArrayList<Boolean> dispatchPopAccess(
			AccessibilityEvent accessibilityEvent) {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).dispatchPopAccess(
					accessibilityEvent));
		return _returns;
	}

	/**
	 * This method is the last chance for the focused view and its ancestors to
	 * respond to an arrow key.
	 * 
	 * @param focused
	 *            The currently focused view.
	 * @param direction
	 *            The direction focus wants to move. One of FOCUS_UP,
	 *            FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT.
	 * @return True if the this view consumed this unhandled move.
	 */
	public ArrayList<Boolean> dispatchMove(
			VaporView<? extends View, ?> focused, int direction) {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).dispatchMove(focused,
					direction));
		return _returns;
	}

	/**
	 * Called when the window containing this view gains or loses window focus.
	 * 
	 * @param windowHasFocus
	 *            True if the window containing this view now has focus, false
	 *            otherwise.
	 * @return self
	 */
	public self dispatchFocus(boolean windowHasFocus) {
		for (X vaporView : members)
			vaporView.dispatchFocus(windowHasFocus);
		return (self) this;

	}

	/**
	 * Dispatch a key event to the next view on the focus path. This path runs
	 * from the top of the view tree down to the currently focused view. If this
	 * view has focus, it will dispatch to itself. Otherwise it will dispatch
	 * the next node down the focus path. This method also fires any key
	 * listeners.
	 * 
	 * @param keyEvent
	 *            The key event to be dispatched.
	 * @return True if the event was handled, false otherwise.
	 */
	public ArrayList<Boolean> dispatchKey(KeyEvent keyEvent) {
		return dispatchKey(keyEvent, false);
	}

	/**
	 * Dispatch a key event to the next view on the focus path, optionally
	 * before it is processed by any input method associated with the view
	 * hierarchy.
	 * 
	 * @param keyEvent
	 * @param preInputProcessed
	 *            true if it is processed by any input method associated with
	 *            the view hierarchy
	 * @return True if the event was handled, false otherwise.
	 */
	public ArrayList<Boolean> dispatchKey(KeyEvent keyEvent,
			boolean preInputProcessed) {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).dispatchKey(keyEvent,
					preInputProcessed));
		return _returns;
	}

	/**
	 * Pass the touch screen motion event down to the target view, or this view
	 * if it is the target.
	 * 
	 * @param touchEvent
	 *            The motion event to be dispatched.
	 * @return True if the event was handled by the view, false otherwise.
	 */
	public ArrayList<Boolean> dispatchTouch(MotionEvent touchEvent) {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).dispatchTouch(touchEvent));
		return _returns;
	}

	/**
	 * Pass a trackball motion event down to the focused view.
	 * 
	 * @param trackballEvent
	 *            The motion event to be dispatched.
	 * @return True if the event was handled by the view, false otherwise.
	 */
	public ArrayList<Boolean> dispatchTrackball(MotionEvent trackballEvent) {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).dispatchTrackball(
					trackballEvent));
		return _returns;
	}

	/**
	 * Dispatch callbacks to sysViz($change systemUiVisibilityChangeListener)
	 * down the view hierarchy, or optionally dispatch callbacks to
	 * winSysVizChanged(int) down the view hierarchy..
	 * 
	 * @param uiVisibility
	 * @param windowVisibility
	 * @return self
	 */
	public self dispatchSysViz(int uiVisibility, boolean windowVisibility) {
		for (X vaporView : members)
			vaporView.dispatchSysViz(uiVisibility, windowVisibility);
		return (self) this;

	}

	/**
	 * Dispatch a window visibility change down the view hierarchy.
	 * 
	 * @param visibility
	 *            The new visibility of the window.
	 * @return self
	 */
	public self dispatchViz(int visibility) {
		for (X vaporView : members)
			vaporView.dispatchViz(visibility);
		return (self) this;

	}

	/**
	 * Gets the logical display to which the view's window has been attached.
	 * 
	 * @return The logical display, or null if the view is not currently
	 *         attached to a window.
	 */
	public ArrayList<Display> display() {
		int _size = this.members.size();
		ArrayList<Display> _returns = new ArrayList<Display>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).display());
		return _returns;
	}

	/**
	 * Starts a drag and drop operation. When your application calls this
	 * method, it passes a View.DragShadowBuilder object to the system. The
	 * system calls this object's onProvideShadowMetrics(Point, Point) to get
	 * metrics for the drag shadow, and then calls the object's
	 * onDrawShadow(Canvas) to draw the drag shadow itself.
	 * 
	 * @param clipData
	 *            A ClipData object pointing to the data to be transferred by
	 *            the drag and drop operation.
	 * @param shadowBuilder
	 *            A View.DragShadowBuilder object for building the drag shadow.
	 * @param myLocalState
	 *            An Object containing local data about the drag and drop
	 *            operation. This Object is put into every DragEvent object sent
	 *            by the system during the current drag.
	 * @param flags
	 *            Flags that control the drag and drop operation. No flags are
	 *            currently defined, so the parameter should be set to 0.
	 * @return true if the method completes successfully, or false if it fails
	 *         anywhere. Returning false means the system was unable to do a
	 *         drag, and so no drag operation is in progress.
	 */
	public final ArrayList<Boolean> drag(ClipData clipData,
			View.DragShadowBuilder shadowBuilder, Object myLocalState, int flags) {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).drag(clipData, shadowBuilder,
					myLocalState, flags));
		return _returns;
	}

	/**
	 * Register a drag event listener callback object for this View.
	 * 
	 * @param dragListener
	 *            An implementation of View.OnDragListener.
	 * @return self
	 */
	public self drag(vapor.listeners.view.$drag dragListener) {
		for (X vaporView : members)
			vaporView.drag(dragListener);
		return (self) this;

	}

	/**
	 * Fluent equivalent Vapor method for invoking onDragEvent(DragEvent), that
	 * handles drag events sent by the system following a call to startDrag().
	 * 
	 * @param dragEvent
	 *            The DragEvent sent by the system.
	 * @return true if the method was successful, otherwise false.
	 */
	public ArrayList<Boolean> drag(DragEvent dragEvent) {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).drag(dragEvent));
		return _returns;
	}

	/**
	 * Manually render this view (and all of its children) to the given Canvas.
	 * 
	 * @param canvas
	 *            The Canvas to which the View is rendered.
	 * @return self
	 */
	public self draw(Canvas canvas) {
		for (X vaporView : members)
			vaporView.draw(canvas);
		return (self) this;

	}

	/**
	 * Calling this method is equivalent to calling drawCache(false).
	 * 
	 * @return A non-scaled bitmap representing this view or null if cache is
	 *         disabled.
	 */
	public ArrayList<Bitmap> drawCache() {
		int _size = this.members.size();
		ArrayList<Bitmap> _returns = new ArrayList<Bitmap>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).drawCache());
		return _returns;
	}

	/**
	 * Returns the bitmap in which this view drawing is cached.
	 * 
	 * @param autoScale
	 *            Indicates whether the generated bitmap should be scaled based
	 *            on the current density of the screen when the application is
	 *            in compatibility mode.
	 * @return A bitmap representing this view or null if cache is disabled.
	 */
	public ArrayList<Bitmap> drawCache(boolean autoScale) {
		int _size = this.members.size();
		ArrayList<Bitmap> _returns = new ArrayList<Bitmap>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).drawCache(autoScale));
		return _returns;
	}

	/**
	 * Indicates whether the drawing cache is enabled for this view.
	 * 
	 * @return true if the drawing cache is enabled
	 */
	public ArrayList<Boolean> drawCached() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).drawCached());
		return _returns;
	}

	/**
	 * Enables or disables the drawing cache.
	 * 
	 * @param enabled
	 *            true to enable the drawing cache, false otherwise
	 * @return self
	 */
	public self drawCached(boolean enabled) {
		for (X vaporView : members)
			vaporView.drawCached(enabled);
		return (self) this;

	}

	/**
	 * The background color to used for the drawing cache's bitmap
	 * 
	 * @return The background color to used for the drawing cache's bitmap
	 */
	public ArrayList<Integer> drawCacheBgColor() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).drawCacheBgColor());
		return _returns;
	}

	/**
	 * Setting a solid background color for the drawing cache's bitmaps will
	 * improve performance and memory usage.
	 * 
	 * @param color
	 *            The background color to use for the drawing cache's bitmap
	 * @return self
	 */
	public self drawCacheBgColor(int color) {
		for (X vaporView : members)
			vaporView.drawCacheBgColor(color);
		return (self) this;

	}

	/**
	 * Frees the resources used by the drawing cache.
	 * 
	 * @return self
	 */
	public self destroyDrawCache() {
		for (X vaporView : members)
			vaporView.destroyDrawCache();
		return (self) this;

	}

	/**
	 * Returns the quality of the drawing cache.
	 * 
	 * @return One of DRAWING_CACHE_QUALITY_AUTO, DRAWING_CACHE_QUALITY_LOW, or
	 *         DRAWING_CACHE_QUALITY_HIGH
	 */
	public ArrayList<Integer> drawCacheQual() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).drawCacheQual());
		return _returns;
	}

	/**
	 * Set the drawing cache quality of this view.
	 * 
	 * @param quality
	 *            One of DRAWING_CACHE_QUALITY_AUTO, DRAWING_CACHE_QUALITY_LOW,
	 *            or DRAWING_CACHE_QUALITY_HIGH
	 * @return self
	 */
	public self drawCacheQual(int quality) {
		for (X vaporView : members)
			vaporView.drawCacheQual(quality);
		return (self) this;

	}

	/**
	 * Returns the bitmap in which this view drawing is cached.
	 * 
	 * @param autoScale
	 * @return
	 */
	public ArrayList<Bitmap> drawCacheScaled(boolean autoScale) {
		int _size = this.members.size();
		ArrayList<Bitmap> _returns = new ArrayList<Bitmap>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).drawCacheScaled(autoScale));
		return _returns;
	}

	/**
	 * Return the visible drawing bounds of your view.
	 * 
	 * @param outRect
	 *            The (scrolled) drawing bounds of the view.
	 * @return self
	 */
	public self drawRect(Rect outRect) {
		for (X vaporView : members)
			vaporView.drawRect(outRect);
		return (self) this;

	}

	/**
	 * Return an array of resource IDs of the drawable states representing the
	 * current state of the view.
	 * 
	 * @return The current drawable state
	 */
	public final ArrayList<Integer[]> drawState() {
		int _size = this.members.size();
		ArrayList<Integer[]> _returns = new ArrayList<Integer[]>(_size);
		for (int _index = 0; _index < _size; _index++) {

			// We cannot implicitly convert int[] to Integer[], so we do it
			// manually
			int[] values = this.members.get(_index).drawState();
			Integer[] _values = new Integer[values.length];

			for (int _i = 0; _i < values.length; _i++)
				_values[_i] = Integer.valueOf(values[_i]);

			_returns.add(_values);
		}
		return _returns;
	}

	/**
	 * Return the time at which the drawing of the view hierarchy started.
	 * 
	 * @return the drawing start time in milliseconds
	 */
	public ArrayList<Long> drawTime() {
		int _size = this.members.size();
		ArrayList<Long> _returns = new ArrayList<Long>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).drawTime());
		return _returns;
	}

	/**
	 * Indicates whether this View is currently in edit mode.
	 * 
	 * @return True if this View is in edit mode, false otherwise.
	 */
	public ArrayList<Boolean> editing() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).editing());
		return _returns;
	}

	/**
	 * Returns the enabled status for this view.
	 * 
	 * @return True if this view is enabled, false otherwise.
	 */
	public ArrayList<Boolean> enabled() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).enabled());
		return _returns;
	}

	/**
	 * Set the enabled state of this view.
	 * 
	 * @param enabled
	 *            True if this view is enabled, false otherwise.
	 * @return self
	 */
	public self enabled(boolean enabled) {
		for (X vaporView : members)
			vaporView.enabled(enabled);
		return (self) this;

	}

	/**
	 * Set the size of the faded edge used to indicate that more content in this
	 * view is available.
	 * 
	 * @param length
	 *            The size in pixels of the faded edge used to indicate that
	 *            more content in this view is visible.
	 * @return self
	 */
	public self fadeEdge(int length) {
		for (X vaporView : members)
			vaporView.fadeEdge(length);
		return (self) this;

	}

	/**
	 * Look for a child view with the given id. If this view has the given id,
	 * return this view.
	 * 
	 * @param id
	 *            The id to search for.
	 * @return The view that has the given id in the hierarchy or null
	 */
	public final ArrayList<VaporView<? extends View, ?>> find(int id) {
		int _size = this.members.size();
		ArrayList<VaporView<? extends View, ?>> _returns = new ArrayList<VaporView<? extends View, ?>>(
				_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).find(id));
		return _returns;
	}

	/**
	 * Look for a child view with the given tag. If this view has the given tag,
	 * return this view.
	 * 
	 * @param tag
	 *            The tag to search for, using "tag.equals(getTag())".
	 * @return The View that has the given tag in the hierarchy or null
	 */
	public final ArrayList<VaporView<? extends View, ?>> find(Object tag) {
		int _size = this.members.size();
		ArrayList<VaporView<? extends View, ?>> _returns = new ArrayList<VaporView<? extends View, ?>>(
				_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).find(tag));
		return _returns;
	}

	/**
	 * Finds the Views that contain given text.
	 * 
	 * @param outViews
	 *            The output list of matching Views.
	 * @param searched
	 *            The text to match against.
	 * @param flags
	 * @return self
	 */
	public self find(ArrayList<VaporView<? extends View, ?>> outViews,
			CharSequence searched, int flags) {
		for (X vaporView : members)
			vaporView.find(outViews, searched, flags);
		return (self) this;

	}

	/**
	 * Fluent equivalent Vapor method for invoking onFinishTemporaryDetach(),
	 * called after onStartTemporaryDetach() when the container is done changing
	 * the view.
	 * 
	 * @return
	 */
	public self finishTempDetach() {
		for (X vaporView : members)
			vaporView.finishTempDetach();
		return (self) this;

	}

	/**
	 * Check for state of 'If this method returns true, the default
	 * implementation of fits(boolean) will be executed'.
	 * 
	 * @return Returns true if the default implementation of fits(boolean) will
	 *         be executed.
	 */
	public ArrayList<Boolean> fits() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).fits());
		return _returns;
	}

	/**
	 * Sets whether or not this view should account for system screen
	 * decorations such as the status bar and inset its content; that is,
	 * controlling whether the default implementation of
	 * fitSystemWindows(boolean) will be executed.
	 * 
	 * @param fitSystemWindows
	 *            If true, then the default implementation of
	 *            fitSystemWindows(Rect) will be executed.
	 * @return self
	 */
	public self fits(boolean fitSystemWindows) {
		for (X vaporView : members)
			vaporView.fits(fitSystemWindows);
		return (self) this;

	}

	/**
	 * Register a callback to be invoked when focus of this view changed.
	 * 
	 * @param focusChangeListener
	 *            Register a callback to be invoked when focus of this view
	 *            changed.
	 * @return self
	 */
	public self focus(vapor.listeners.view.$focus focusChangeListener) {
		for (X vaporView : members)
			vaporView.focus(focusChangeListener);
		return (self) this;

	}

	/**
	 * Returns true if this view has focus itself
	 * 
	 * @return True if this view has focus, false otherwise.
	 */
	public ArrayList<Boolean> focused() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).focused());
		return _returns;
	}

	/**
	 * Returns true if this view has focus iteself, or is the ancestor of the
	 * view that has focus.
	 * 
	 * @return True if this view has or contains focus, false otherwise.
	 */
	public ArrayList<Boolean> focusedExt() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).focusedExt());
		return _returns;
	}

	/**
	 * Returns the focus-change callback registered for this view.
	 * 
	 * @return The callback, or null if one is not registered.
	 */
	public ArrayList<OnFocusChangeListener> focusListener() {
		int _size = this.members.size();
		ArrayList<OnFocusChangeListener> _returns = new ArrayList<OnFocusChangeListener>(
				_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).focusListener());
		return _returns;
	}

	/**
	 * When a view has focus and the user navigates away from it, the next view
	 * is searched for starting from the rectangle filled in by this method.
	 * 
	 * @param rect
	 *            The rectangle to fill in, in this view's coordinates.
	 * @return self
	 */
	public self focusedRect(Rect rect) {
		for (X vaporView : members)
			vaporView.focusedRect(rect);
		return (self) this;

	}

	/**
	 * Returns true if this view is focusable or if it contains a reachable View
	 * for which focusableExt() returns true.
	 * 
	 * @param includeChildren
	 *            true if should check the view's children for a focusable too
	 * @return True if the view is focusable or if the view contains a focusable
	 *         View, false otherwise.
	 */
	public ArrayList<Boolean> focusable() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).focusable());
		return _returns;
	}

	/**
	 * Set whether this view can receive the focus.
	 * 
	 * @param focusable
	 * @return
	 */
	public self focusable(boolean focusable) {
		for (X vaporView : members)
			vaporView.focusable(focusable);
		return (self) this;

	}

	/**
	 * Adds any focusable views that are descendants of this view (possibly
	 * including this view if it is focusable itself) to views.
	 * 
	 * @param views
	 *            Focusable views found so far or null if all we are interested
	 *            is the number of focusables.
	 * @param direction
	 *            The direction of the focus.
	 * @return self
	 */
	public self focusables(ArrayList<VaporView<? extends View, ?>> views,
			int direction) {
		for (X vaporView : members)
			vaporView.focusables(views, direction);
		return (self) this;

	}

	/**
	 * Adds any focusable views that are descendants of this view (possibly
	 * including this view if it is focusable itself) to views.
	 * 
	 * @param views
	 *            Focusable views found so far or null if all we are interested
	 *            is the number of focusables.
	 * @param direction
	 *            The direction of the focus.
	 * @param focusableMode
	 *            The type of focusables to be added.
	 * @return self
	 */
	public self focusables(ArrayList<VaporView<? extends View, ?>> views,
			int direction, int focusableMode) {
		for (X vaporView : members)
			vaporView.focusables(views, direction, focusableMode);
		return (self) this;

	}

	/**
	 * Returns true if this view is focusable or if it contains a reachable View
	 * for which focusableExt() returns true. A "reachable focusableExt()" is a
	 * View whose parents do not block descendants focus. Only VISIBLE views are
	 * considered focusable.
	 * 
	 * @return True if the view is focusable or if the view contains a focusable
	 *         View, false otherwise.
	 */
	public ArrayList<Boolean> focusableExt() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).focusableExt());
		return _returns;
	}

	/**
	 * Change the view's z order in the tree, so it's on top of other sibling
	 * views.
	 * 
	 * @return self
	 */
	public self front() {
		for (X vaporView : members)
			vaporView.front();
		return (self) this;

	}

	/**
	 * Generate a value suitable for use in id(int). This value will not collide
	 * with ID values generated at build time by aapt for R.id.
	 * 
	 * @return a generated ID value
	 */
	public ArrayList<Integer> genViewId() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(VaporView.genViewId());
		return _returns;
	}

	/**
	 * 
	 * @return A handler associated with the thread running the View. This
	 *         handler can be used to pump events in the UI events queue.
	 */
	public ArrayList<Handler> handler() {
		int _size = this.members.size();
		ArrayList<Handler> _returns = new ArrayList<Handler>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).handler());
		return _returns;
	}

	/**
	 * Whether this view should have haptic feedback enabled for events long
	 * presses.
	 * 
	 * @return true if this view has haptic feedback enabled for events long
	 *         presses.
	 */
	public ArrayList<Boolean> haptic() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).haptic());
		return _returns;
	}

	/**
	 * Set whether this view should have haptic feedback for events such as long
	 * presses.
	 * 
	 * @param hapticFeedbackEnabled
	 * @return
	 */
	public self haptic(boolean hapticFeedbackEnabled) {
		for (X vaporView : members)
			vaporView.haptic(hapticFeedbackEnabled);
		return (self) this;

	}

	/**
	 * Provide haptic feedback to the user for this view.
	 * 
	 * @param feedbackConstant
	 *            One of the constants defined in HapticFeedbackConstants
	 * @return
	 */
	public ArrayList<Boolean> haptic(int feedbackConstant) {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).haptic(feedbackConstant));
		return _returns;
	}

	/**
	 * Like performHapticFeedback(int), with additional options.
	 * 
	 * @param feedbackConstant
	 * @param flags
	 * @return
	 */
	public ArrayList<Boolean> haptic(int feedbackConstant, int flags) {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).haptic(feedbackConstant,
					flags));
		return _returns;
	}

	/**
	 * Return the height of your view.
	 * 
	 * @return The height of your view, in pixels.
	 */
	public ArrayList<Integer> height() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).height());
		return _returns;
	}

	/**
	 * Hit rectangle in parent's coordinates
	 * 
	 * @param outRect
	 *            The hit rectangle of the view.
	 * @return self
	 */
	public self hitRect(Rect outRect) {
		for (X vaporView : members)
			vaporView.hitRect(outRect);
		return (self) this;

	}

	/**
	 * Indicate whether the horizontal edges are faded when the view is scrolled
	 * horizontally.
	 * 
	 * @return true if the horizontal edges should are faded on scroll, false
	 *         otherwise
	 */
	public ArrayList<Boolean> fadesXEdges() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).fadesXEdges());
		return _returns;
	}

	/**
	 * Define whether the horizontal edges should be faded when this view is
	 * scrolled horizontally.
	 * 
	 * @param horizontalFadingEdgeEnabled
	 *            true if the horizontal edges should be faded when the view is
	 *            scrolled horizontally
	 * @return self
	 */
	public self fadesXEdges(boolean horizontalFadingEdgeEnabled) {
		for (X vaporView : members)
			vaporView.fadesXEdges(horizontalFadingEdgeEnabled);
		return (self) this;

	}

	/**
	 * Returns the size of the horizontal faded edges used to indicate that more
	 * content in this view is visible.
	 * 
	 * @return The size in pixels of the horizontal faded edge or 0 if
	 *         horizontal faded edges are not enabled for this view.
	 */
	public ArrayList<Integer> xFadeEdge() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).xFadeEdge());
		return _returns;
	}

	/**
	 * Indicate whether the horizontal scrollbar should be drawn or not. The
	 * scrollbar is not drawn by default.
	 * 
	 * @return true if the horizontal scrollbar should be painted, false
	 *         otherwise
	 */
	public ArrayList<Boolean> xScrolls() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).xScrolls());
		return _returns;
	}

	/**
	 * Define whether the horizontal scrollbar should be drawn or not.
	 * 
	 * @param horizontalScrollBarEnabled
	 *            true if the horizontal scrollbar should be painted
	 * @return self
	 */
	public self xScrolls(boolean horizontalScrollBarEnabled) {
		for (X vaporView : members)
			vaporView.xScrolls(horizontalScrollBarEnabled);
		return (self) this;

	}

	/**
	 * Fluent equivalent Vapor method for invoking onHoverEvent(MotionEvent),
	 * used to handle hover events.
	 * 
	 * @param hoverEvent
	 *            The motion event that describes the hover.
	 * @return True if the view handled the hover event
	 */
	public ArrayList<Boolean> hover(MotionEvent hoverEvent) {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).hover(hoverEvent));
		return _returns;
	}

	/**
	 * Register a callback to be invoked when a hover event is sent to this
	 * view.
	 * 
	 * @param hoverListener
	 *            the hover listener to attach to this view
	 * @return self
	 */
	public self hover(vapor.listeners.view.$hover hoverListener) {
		for (X vaporView : members)
			vaporView.hover(hoverListener);
		return (self) this;

	}

	/**
	 * Fluent Vapor method for invoking onHoverChanged(boolean), used to handle
	 * hover state changes.
	 * 
	 * @param hovered
	 * @return self
	 */
	public self hoverChanged(boolean hovered) {
		for (X vaporView : members)
			vaporView.hoverChanged(hovered);
		return (self) this;

	}

	/**
	 * Returns true if the view is currently hovered.
	 * 
	 * @return True if the view is currently hovered.
	 */
	public ArrayList<Boolean> hovered() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).hovered());
		return _returns;
	}

	/**
	 * Sets whether the view is currently hovered.
	 * 
	 * @param hovered
	 *            True if the view is hovered.
	 * @return self
	 */
	public self hovered(boolean hovered) {
		for (X vaporView : members)
			vaporView.hovered(hovered);
		return (self) this;

	}

	/**
	 * Returns this view's identifier.
	 * 
	 * @return a positive integer used to identify the view or NO_ID if the view
	 *         has no ID
	 */
	public ArrayList<Integer> id() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).id());
		return _returns;
	}

	/**
	 * Sets the identifier for this view.
	 * 
	 * @param id
	 *            a number used to identify the view
	 * @return self
	 */
	public self id(int id) {
		for (X vaporView : members)
			vaporView.id(id);
		return (self) this;

	}

	/**
	 * Gets the mode for determining whether this View is important for
	 * accessibility which is if it fires accessibility events and if it is
	 * reported to accessibility services that query the screen.
	 * 
	 * @return The mode for determining whether a View is important for
	 *         accessibility.
	 */
	public ArrayList<Integer> vipAccess() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).vipAccess());
		return _returns;
	}

	/**
	 * Sets how to determine whether this view is important for accessibility
	 * which is if it fires accessibility events and if it is reported to
	 * accessibility services that query the screen.
	 * 
	 * @param mode
	 *            How to determine whether this view is important for
	 *            accessibility.
	 * @return self
	 */
	public self vipAccess(int mode) {
		for (X vaporView : members)
			vaporView.vipAccess(mode);
		return (self) this;

	}

	/**
	 * Fluent equivalent Vapor method for invoking
	 * onInitializeAccessibilityEventh(AccessibilityEvent), used to initialize
	 * an AccessibilityEvent with information about this View which is the event
	 * source. In other words, the source of an accessibility event is the view
	 * whose state change triggered firing the event.
	 * 
	 * @param accessibilityEvent
	 *            The event to initialize.
	 * @return self
	 */
	public self initAccess(AccessibilityEvent accessibilityEvent) {
		for (X vaporView : members)
			vaporView.initAccess(accessibilityEvent);
		return (self) this;

	}

	/**
	 * Fluent equivalent Vapor method for invoking
	 * onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo), used to
	 * initialize an AccessibilityNodeInfo with information about this view.
	 * 
	 * @param accessibilityNodeInfo
	 *            The instance to initialize.
	 * @return self
	 */
	public self initAccess(AccessibilityNodeInfo accessibilityNodeInfo) {
		for (X vaporView : members)
			vaporView.initAccess(accessibilityNodeInfo);
		return (self) this;

	}

	/**
	 * Invalidate the whole view.
	 * 
	 * @return self
	 */
	public self invalidate() {
		for (X vaporView : members)
			vaporView.invalidate();
		return (self) this;

	}

	/**
	 * Mark the area defined by dirty as needing to be drawn.
	 * 
	 * @param dirty
	 *            the rectangle representing the bounds of the dirty region
	 * @return self
	 */
	public self invalidate(Rect dirty) {
		for (X vaporView : members)
			vaporView.invalidate(dirty);
		return (self) this;

	}

	/**
	 * Mark the area defined by the rect (left,top,right,bottom) as needing to
	 * be drawn.
	 * 
	 * @param left
	 *            the left position of the dirty region
	 * @param top
	 *            the top position of the dirty region
	 * @param right
	 *            the right position of the dirty region
	 * @param bottom
	 *            the bottom position of the dirty region
	 * @return self
	 */
	public self invalidate(int left, int top, int right, int bottom) {
		for (X vaporView : members)
			vaporView.invalidate(left, top, right, bottom);
		return (self) this;

	}

	/**
	 * Equivalent fluent Vapor method for invoking invalidateDrawable(Drawable),
	 * invalidates the specified Drawable.
	 * 
	 * @param drawable
	 *            the drawable to invalidate
	 * @return self
	 */
	public self invalidate(Drawable drawable) {
		for (X vaporView : members)
			vaporView.invalidate(drawable);
		return (self) this;

	}

	/**
	 * Call Drawable.jumpToCurrentState() on all Drawable objects associated
	 * with this view.
	 * 
	 * @return self
	 */
	public self jumpState() {
		for (X vaporView : members)
			vaporView.jumpState();
		return (self) this;

	}

	/**
	 * Returns whether the screen should remain on, corresponding to the current
	 * value of KEEP_SCREEN_ON.
	 * 
	 * @return Returns true if KEEP_SCREEN_ON is set.
	 */
	public ArrayList<Boolean> keepOn() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).keepOn());
		return _returns;
	}

	/**
	 * Controls whether the screen should remain on, modifying the value of
	 * KEEP_SCREEN_ON.
	 * 
	 * @param keepScreenOn
	 *            Supply true to set KEEP_SCREEN_ON.
	 * @return self
	 */
	public self keepOn(boolean keepScreenOn) {
		for (X vaporView : members)
			vaporView.keepOn(keepScreenOn);
		return (self) this;

	}

	/**
	 * Register a callback to be invoked when a hardware key is pressed in this
	 * view.
	 * 
	 * @param keyListener
	 *            the key listener to attach to this view
	 * @return self
	 */
	public self key(vapor.listeners.view.$key keyListener) {
		for (X vaporView : members)
			vaporView.key(keyListener);
		return (self) this;

	}

	/**
	 * Fluent equivalent Vapor method for invoking onKeyDown(KeyEvent), called
	 * when KEYCODE_DPAD_CENTER or KEYCODE_ENTER is released, if the view is
	 * enabled and clickable.
	 * 
	 * @param keyEvent
	 *            The KeyEvent object that defines the button action.
	 * @return If you handled the event, return true. If you want to allow the
	 *         event to be handled by the next receiver, return false.
	 */
	public ArrayList<Boolean> keyDown(KeyEvent keyEvent) {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).keyDown(keyEvent));
		return _returns;
	}

	/**
	 * Fluent equivalent Vapor method for invoking onKeyLongPress(int,KeyEvent),
	 * called always returns false (doesn't handle the event).
	 * 
	 * @param keyEvent
	 *            Description of the key event.
	 * @return If you handled the event, return true. If you want to allow the
	 *         event to be handled by the next receiver, return false.
	 */
	public ArrayList<Boolean> keyLongPress(KeyEvent keyEvent) {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).keyLongPress(keyEvent));
		return _returns;
	}

	/**
	 * Fluent equivalent Vapor method for invoking
	 * onKeyMultiple(int,int,KeyEvent), always returns false (doesn't handle the
	 * event).
	 * 
	 * @param repeatCount
	 *            The number of times the action was made.
	 * @param keyEvent
	 *            The KeyEvent object that defines the button action.
	 * @return If you handled the event, return true. If you want to allow the
	 *         event to be handled by the next receiver, return false.
	 */
	public ArrayList<Boolean> keyMulti(int repeatCount, KeyEvent keyEvent) {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).keyMulti(repeatCount,
					keyEvent));
		return _returns;
	}

	/**
	 * Fluent equivalent Vapor method for invoking onKeyPreIme(KeyEvent), used
	 * to handle a key event before it is processed by any input method
	 * associated with the view hierarchy.
	 * 
	 * @param keyEvent
	 *            Description of the key event.
	 * @return If you handled the event, return true. If you want to allow the
	 *         event to be handled by the next receiver, return false.
	 */
	public ArrayList<Boolean> keyPreIme(KeyEvent keyEvent) {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).keyPreIme(keyEvent));
		return _returns;
	}

	/**
	 * Fluent equivalent Vapor method for invoking onKeyShortcut(KeyEvent),
	 * called on the focused view when a key shortcut event is not handled.
	 * 
	 * @param keyEvent
	 *            Description of the key event.
	 * @return If you handled the event, return true. If you want to allow the
	 *         event to be handled by the next receiver, return false.
	 */
	public ArrayList<Boolean> keyHot(KeyEvent keyEvent) {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).keyHot(keyEvent));
		return _returns;
	}

	/**
	 * Fluent equivalent Vapor method for invoking onKeyUp(int,KeyEvent), called
	 * when KEYCODE_DPAD_CENTER or KEYCODE_ENTER is released.
	 * 
	 * @param keyEvent
	 *            The KeyEvent object that defines the button action.
	 * @return If you handled the event, return true. If you want to allow the
	 *         event to be handled by the next receiver, return false.
	 */
	public ArrayList<Boolean> keyUp(KeyEvent keyEvent) {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).keyUp(keyEvent));
		return _returns;
	}

	/**
	 * Gets the id of a view for which this view serves as a label for
	 * accessibility purposes.
	 * 
	 * @return The labeled view id.
	 */
	public ArrayList<Integer> labelFor() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).labelFor());
		return _returns;
	}

	/**
	 * Sets the id of a view for which this view serves as a label for
	 * accessibility purposes.
	 * 
	 * @param id
	 *            The labeled view id.
	 * @return self
	 */
	public self labelFor(int id) {
		for (X vaporView : members)
			vaporView.labelFor(id);
		return (self) this;

	}

	/**
	 * Updates the Paint object used with the current layer (used only if the
	 * current layer type is not set to LAYER_TYPE_NONE). Changed properties of
	 * the Paint provided to layerType(int, android.graphics.Paint) will be used
	 * the next time the View is redrawn, but layerPaint(android.graphics.Paint)
	 * must be called to ensure that the view gets redrawn immediately.
	 * 
	 * @param paint
	 *            The paint used to compose the layer. This argument is optional
	 *            and can be null. It is ignored when the layer type is
	 *            LAYER_TYPE_NONE
	 * @return self
	 */
	public self layerPaint(Paint paint) {
		for (X vaporView : members)
			vaporView.layerPaint(paint);
		return (self) this;

	}

	/**
	 * Indicates what type of layer is currently associated with this view.
	 * 
	 * @return LAYER_TYPE_NONE, LAYER_TYPE_SOFTWARE or LAYER_TYPE_HARDWARE
	 */
	public ArrayList<Integer> layerType() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).layerType());
		return _returns;
	}

	/**
	 * Specifies the type of layer backing this view.
	 * 
	 * @param layerType
	 *            The type of layer to use with this view, must be one of
	 *            LAYER_TYPE_NONE, LAYER_TYPE_SOFTWARE or LAYER_TYPE_HARDWARE
	 * @param paint
	 *            The paint used to compose the layer. This argument is optional
	 *            and can be null. It is ignored when the layer type is
	 *            LAYER_TYPE_NONE
	 * @return self
	 */
	public self layerType(int layerType, Paint paint) {
		for (X vaporView : members)
			vaporView.layerType(layerType, paint);
		return (self) this;

	}

	/**
	 * Assign a size and position to a view and all of its descendants
	 * 
	 * @param left
	 *            Left position, relative to parent
	 * @param top
	 *            Top position, relative to parent
	 * @param right
	 *            Right position, relative to parent
	 * @param bottom
	 *            Bottom position, relative to parent
	 * @return self
	 */
	public self layout(int left, int top, int right, int bottom) {
		for (X vaporView : members)
			vaporView.layout(left, top, right, bottom);
		return (self) this;

	}

	/**
	 * Add a listener that will be called when the bounds of the view change due
	 * to layout processing.
	 * 
	 * @param layoutChangeListener
	 *            The listener that will be called when layout bounds change.
	 * @return self
	 */
	public self layout(vapor.listeners.view.$layout layoutChangeListener) {
		for (X vaporView : members)
			vaporView.layout(layoutChangeListener);
		return (self) this;

	}

	/**
	 * Returns the resolved layout direction for this view.
	 * 
	 * @return LAYOUT_DIRECTION_RTL if the layout direction is RTL or returns
	 *         LAYOUT_DIRECTION_LTR if the layout direction is not RTL. For
	 *         compatibility, this will return LAYOUT_DIRECTION_LTR if API
	 *         version is lower than JELLY_BEAN_MR1.
	 */
	public ArrayList<Integer> layoutDirection() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).layoutDirection());
		return _returns;
	}

	/**
	 * Set the layout direction for this view. This will propagate a reset of
	 * layout direction resolution to the view's children and resolve layout
	 * direction for this view.
	 * 
	 * @param layoutDirection
	 *            the layout direction to set. Should be one of:
	 *            LAYOUT_DIRECTION_LTR, LAYOUT_DIRECTION_RTL,
	 *            LAYOUT_DIRECTION_INHERIT, LAYOUT_DIRECTION_LOCALE. Resolution
	 *            will be done if the value is set to LAYOUT_DIRECTION_INHERIT.
	 *            The resolution proceeds up the parent chain of the view to get
	 *            the value. If there is no parent, then it will return the
	 *            default LAYOUT_DIRECTION_LTR.
	 * @return self
	 */
	public self layoutDirection(int layoutDirection) {
		for (X vaporView : members)
			vaporView.layoutDirection(layoutDirection);
		return (self) this;

	}

	/**
	 * Forces this view to be laid out during the next layout pass.
	 * 
	 * @return self
	 */
	public self layoutForce() {
		for (X vaporView : members)
			vaporView.layoutForce();
		return (self) this;

	}

	/**
	 * Indicates whether or not this view's layout will be requested during the
	 * next hierarchy layout pass.
	 * 
	 * @return true if the layout will be forced during next layout pass
	 */
	public ArrayList<Boolean> layoutReqd() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).layoutReqd());
		return _returns;
	}

	/**
	 * Get the LayoutParams associated with this view.
	 * 
	 * @return The LayoutParams associated with this view, or null if no
	 *         parameters have been set yet
	 */
	public ArrayList<LayoutParams> layoutParams() {
		int _size = this.members.size();
		ArrayList<LayoutParams> _returns = new ArrayList<LayoutParams>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).layoutParams());
		return _returns;
	}

	/**
	 * Set the layout parameters associated with this view.
	 * 
	 * @param params
	 *            The layout parameters for this view, cannot be null
	 * @return self
	 */
	public self layoutParams(ViewGroup.LayoutParams params) {
		for (X vaporView : members)
			vaporView.layoutParams(params);
		return (self) this;

	}

	/**
	 * Left position of this view relative to its parent.
	 * 
	 * @return The left edge of this view, in pixels.
	 */
	public final ArrayList<Integer> left() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).left());
		return _returns;
	}

	/**
	 * Sets the left position of this view relative to its parent.
	 * 
	 * @param left
	 *            The left of this view, in pixels.
	 * @return self
	 */
	public self left(int left) {
		for (X vaporView : members)
			vaporView.left(left);
		return (self) this;

	}

	/**
	 * Call this view's OnLongClickListener, if it is defined.
	 * 
	 * @return True if one of the above receivers consumed the event, false
	 *         otherwise.
	 */
	public ArrayList<Boolean> longClick() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).longClick());
		return _returns;
	}

	/**
	 * Register a callback to be invoked when this view is clicked and held.
	 * 
	 * @param longClickListener
	 *            The callback that will run
	 * @return self
	 */
	public self longClick(vapor.listeners.view.$longClick longClickListener) {
		for (X vaporView : members)
			vaporView.longClick(longClickListener);
		return (self) this;

	}

	/**
	 * Indicates whether this view reacts to long click events or not.
	 * 
	 * @return true if the view is long clickable, false otherwise
	 */
	public ArrayList<Boolean> longClickable() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).longClickable());
		return _returns;
	}

	/**
	 * Enables or disables long click events for this view.
	 * 
	 * @param longClickable
	 *            true to make the view long clickable, false otherwise
	 * @return self
	 */
	public self longClickable(boolean longClickable) {
		for (X vaporView : members)
			vaporView.longClickable(longClickable);
		return (self) this;

	}

	/**
	 * 
	 * @param rect
	 * @return
	 */
	public final ArrayList<Boolean> localRect(Rect rect) {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).localRect(rect));
		return _returns;
	}

	/**
	 * The transform matrix of this view, which is calculated based on the
	 * current rotation, scale, and pivot properties.
	 * 
	 * @return The current transform matrix for the view.
	 */
	public ArrayList<Matrix> matrix() {
		int _size = this.members.size();
		ArrayList<Matrix> _returns = new ArrayList<Matrix>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).matrix());
		return _returns;
	}

	/**
	 * This is called to find out how big a view should be.
	 * 
	 * @param widthMeasureSpec
	 *            Horizontal space requirements as imposed by the parent
	 * @param heightMeasureSpec
	 *            Vertical space requirements as imposed by the parent
	 * @return self
	 */
	public final self measure(int widthMeasureSpec, int heightMeasureSpec) {
		for (X vaporView : members)
			vaporView.measure(widthMeasureSpec, heightMeasureSpec);
		return (self) this;
	}

	/**
	 * Returns the raw height component (that is the result is masked by
	 * MEASURED_SIZE_MASK).
	 * 
	 * @withState true combines measurement with state
	 * @return The raw measured height of this view (optionally combined with
	 *         state).
	 */
	public final ArrayList<Integer> measuredHeight(boolean withState) {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).measuredHeight(withState));
		return _returns;
	}

	/**
	 * Like measuredHeight(boolean), but only returns the raw width component
	 * (that is the result is masked by MEASURED_SIZE_MASK).
	 * 
	 * @return
	 */
	public final ArrayList<Integer> measuredHeight() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).measuredHeight());
		return _returns;
	}

	/**
	 * Return only the state bits of getMeasuredWidthAndState() and
	 * getMeasuredHeightAndState(), combined into one integer.
	 * 
	 * @return
	 */
	public final ArrayList<Integer> measuredState() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).measuredState());
		return _returns;
	}

	/**
	 * Returns the raw width component (that is the result is masked by
	 * MEASURED_SIZE_MASK).
	 * 
	 * @withState true combines measurement with state
	 * @return The raw measured width of this view (optionally combined with
	 *         state).
	 */
	public final ArrayList<Integer> measuredWidth(boolean withState) {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).measuredWidth(withState));
		return _returns;
	}

	/**
	 * Like measuredWidth(boolean), but only returns the raw width component
	 * (that is the result is masked by MEASURED_SIZE_MASK).
	 * 
	 * @return The raw measured width of this view.
	 */
	public final ArrayList<Integer> measuredWidth() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).measuredWidth());
		return _returns;
	}

	/**
	 * Bring up the context menu for this view.
	 * 
	 * @return Whether a context menu was displayed.
	 */
	public ArrayList<Boolean> menu() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).menu());
		return _returns;
	}

	/**
	 * Show the context menu for this view.
	 * 
	 * @param menu
	 *            The context menu to populate
	 * @return self
	 */
	public self menu(ContextMenu menu) {
		for (X vaporView : members)
			vaporView.menu(menu);
		return (self) this;

	}

	/**
	 * Register a callback to be invoked when the context menu for this view is
	 * being built.
	 * 
	 * @param createcContextMenuListener
	 *            The callback that will run
	 * @return self
	 */
	public self menu(vapor.listeners.view.$menu createContextMenuListener) {
		for (X vaporView : members)
			vaporView.menu(createContextMenuListener);
		return (self) this;

	}

	/**
	 * Returns the minimum height of the view.
	 * 
	 * @return the minimum height the view will try to be.
	 */
	public ArrayList<Integer> minHeight() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).minHeight());
		return _returns;
	}

	/**
	 * Sets the minimum height of the view.
	 * 
	 * @param minHeight
	 *            The minimum height the view will try to be.
	 * @return self
	 */
	public self minHeight(int minHeight) {
		for (X vaporView : members)
			vaporView.minHeight(minHeight);
		return (self) this;

	}

	/**
	 * Returns the minimum width of the view.
	 * 
	 * @return the minimum width the view will try to be.
	 */
	public ArrayList<Integer> minWidth() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).minWidth());
		return _returns;
	}

	/**
	 * Sets the minimum width of the view.
	 * 
	 * @param minWidth
	 *            The minimum width the view will try to be.
	 * @return self
	 */
	public self minWidth(int minWidth) {
		for (X vaporView : members)
			vaporView.minWidth(minWidth);
		return (self) this;

	}

	/**
	 * Fluent equivalent Vapor method for invoking
	 * onGenericMotionEvent(MotionEvent), used to handle generic motion events.
	 * 
	 * @param genericMotionEvent
	 *            The generic motion event being processed.
	 * @return True if the event was handled, false otherwise.
	 */
	public ArrayList<Boolean> motion(MotionEvent genericMotionEvent) {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).motion(genericMotionEvent));
		return _returns;
	}

	/**
	 * Register a callback to be invoked when a generic motion event is sent to
	 * this view.
	 * 
	 * @param genericMotionListener
	 *            the generic motion listener to attach to this view
	 * @return self
	 */
	public self motion(vapor.listeners.view.$motion genericMotionListener) {
		for (X vaporView : members)
			vaporView.motion(genericMotionListener);
		return (self) this;

	}

	/**
	 * Gets the id of the view to use when the next focus is FOCUS_DOWN.
	 * 
	 * @return The next focus ID, or NO_ID if the framework should decide
	 *         automatically.
	 */
	public ArrayList<Integer> nextDown() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).nextDown());
		return _returns;
	}

	/**
	 * Sets the id of the view to use when the next focus is FOCUS_DOWN.
	 * 
	 * @param nextFocusDownId
	 *            The next focus ID, or NO_ID if the framework should decide
	 *            automatically.
	 * @return self
	 */
	public self nextDown(int nextFocusDownId) {
		for (X vaporView : members)
			vaporView.nextDown(nextFocusDownId);
		return (self) this;

	}

	/**
	 * Gets the id of the view to use when the next focus is FOCUS_FORWARD.
	 * 
	 * @return The next focus ID, or NO_ID if the framework should decide
	 *         automatically.
	 */
	public ArrayList<Integer> nextForward() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).nextForward());
		return _returns;
	}

	/**
	 * Sets the id of the view to use when the next focus is FOCUS_FORWARD.
	 * 
	 * @param nextFocusForwardId
	 *            The next focus ID, or NO_ID if the framework should decide
	 *            automatically.
	 * @return self
	 */
	public self nextForward(int nextFocusForwardId) {
		for (X vaporView : members)
			vaporView.nextForward(nextFocusForwardId);
		return (self) this;

	}

	/**
	 * Gets the id of the view to use when the next focus is FOCUS_LEFT.
	 * 
	 * @return The next focus ID, or NO_ID if the framework should decide
	 *         automatically.
	 */
	public ArrayList<Integer> nextLeft() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).nextLeft());
		return _returns;
	}

	/**
	 * Sets the id of the view to use when the next focus is FOCUS_LEFT.
	 * 
	 * @param nextFocusLeftId
	 *            The next focus ID, or NO_ID if the framework should decide
	 *            automatically.
	 * @return self
	 */
	public self nextLeft(int nextFocusLeftId) {
		for (X vaporView : members)
			vaporView.nextLeft(nextFocusLeftId);
		return (self) this;

	}

	/**
	 * Gets the id of the view to use when the next focus is FOCUS_RIGHT.
	 * 
	 * @return The next focus ID, or NO_ID if the framework should decide
	 *         automatically.
	 */
	public ArrayList<Integer> nextRight() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).nextRight());
		return _returns;
	}

	/**
	 * Sets the id of the view to use when the next focus is FOCUS_RIGHT.
	 * 
	 * @param nextFocusRightId
	 *            The next focus ID, or NO_ID if the framework should decide
	 *            automatically.
	 * @return self
	 */
	public self nextRight(int nextFocusRightId) {
		for (X vaporView : members)
			vaporView.nextRight(nextFocusRightId);
		return (self) this;

	}

	/**
	 * Gets the id of the view to use when the next focus is FOCUS_UP.
	 * 
	 * @return The next focus ID, or NO_ID if the framework should decide
	 *         automatically.
	 */
	public ArrayList<Integer> nextUp() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).nextUp());
		return _returns;
	}

	/**
	 * Sets the id of the view to use when the next focus is FOCUS_UP.
	 * 
	 * @param nextFocusUpId
	 *            The next focus ID, or NO_ID if the framework should decide
	 *            automatically.
	 * @return self
	 */
	public self nextUp(int nextFocusUpId) {
		for (X vaporView : members)
			vaporView.nextUp(nextFocusUpId);
		return (self) this;

	}

	/**
	 * Returns an AccessibilityNodeInfo representing this view from the point of
	 * view of an AccessibilityService.
	 * 
	 * @return A populated AccessibilityNodeInfo.
	 */
	public ArrayList<AccessibilityNodeInfo> accessNodeInfo() {
		int _size = this.members.size();
		ArrayList<AccessibilityNodeInfo> _returns = new ArrayList<AccessibilityNodeInfo>(
				_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).accessNodeInfo());
		return _returns;
	}

	/**
	 * Gets the provider for managing a virtual view hierarchy rooted at this
	 * View and reported to AccessibilityServices that explore the window
	 * content.
	 * 
	 * @return The provider.
	 */
	public ArrayList<AccessibilityNodeProvider> accessNodeProvider() {
		int _size = this.members.size();
		ArrayList<AccessibilityNodeProvider> _returns = new ArrayList<AccessibilityNodeProvider>(
				_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).accessNodeProvider());
		return _returns;
	}

	/**
	 * Returns whether or not this View draws on its own.
	 * 
	 * @return true if this view has nothing to draw, false otherwise
	 */
	public ArrayList<Boolean> noDraw() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).noDraw());
		return _returns;
	}

	/**
	 * If this view doesn't do any drawing on its own, set this flag to allow
	 * further optimizations.
	 * 
	 * @param willNotDraw
	 *            whether or not this View draw on its own
	 * @return self
	 */
	public self noDraw(boolean willNotDraw) {
		for (X vaporView : members)
			vaporView.noDraw(willNotDraw);
		return (self) this;

	}

	/**
	 * Returns whether or not this View can cache its drawing or not.
	 * 
	 * @return true if this view does not cache its drawing, false otherwise
	 */
	public ArrayList<Boolean> noDrawCache() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).noDrawCache());
		return _returns;
	}

	/**
	 * When a View's drawing cache is enabled, drawing is redirected to an
	 * offscreen bitmap.
	 * 
	 * @param willNotCacheDrawing
	 *            true if this view does not cache its drawing, false otherwise
	 * @return self
	 */
	public self noDrawCache(boolean willNotCacheDrawing) {
		for (X vaporView : members)
			vaporView.noDrawCache(willNotCacheDrawing);
		return (self) this;

	}

	/**
	 * Gets whether the framework should discard touches when the view's window
	 * is obscured by another visible window.
	 * 
	 * @return True if touch filtering is enabled.
	 */
	public ArrayList<Boolean> obscureTouchFilter() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).obscureTouchFilter());
		return _returns;
	}

	/**
	 * Sets whether the framework should discard touches when the view's window
	 * is obscured by another visible window.
	 * 
	 * @param enabled
	 * @return
	 */
	public self obscureTouchFilter(boolean enabled) {
		for (X vaporView : members)
			vaporView.obscureTouchFilter(enabled);
		return (self) this;

	}

	/**
	 * Offset this view's location by the specified amount of pixels.
	 * 
	 * @param offset
	 *            the number of pixels to offset the view by
	 * @return self
	 */
	public self offset(int offset) {
		return offsetLR(offset).offsetTB(offset);
	}

	/**
	 * Offset this view's horizontal location by the specified amount of pixels.
	 * 
	 * @param offset
	 *            the number of pixels to offset the view by
	 * @return self
	 */
	public self offsetLR(int offset) {
		for (X vaporView : members)
			vaporView.offsetLR(offset);
		return (self) this;

	}

	/**
	 * Offset this view's vertical location by the specified number of pixels.
	 * 
	 * @param offset
	 *            the number of pixels to offset the view by
	 * @return self
	 */
	public self offsetTB(int offset) {
		for (X vaporView : members)
			vaporView.offsetTB(offset);
		return (self) this;

	}

	/**
	 * Indicates whether this View is opaque.
	 * 
	 * @return True if this View is guaranteed to be fully opaque, false
	 *         otherwise.
	 */
	public ArrayList<Boolean> opaque() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).opaque());
		return _returns;
	}

	/**
	 * Returns whether this View has content which overlaps.
	 * 
	 * @return true if the content in this view might overlap, false otherwise.
	 */
	public ArrayList<Boolean> overlaps() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).overlaps());
		return _returns;
	}

	/**
	 * Returns the over-scroll mode for this view.
	 * 
	 * @return self view's over-scroll mode.
	 */
	public ArrayList<Integer> overScroll() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).overScroll());
		return _returns;
	}

	/**
	 * Set the over-scroll mode for this view.
	 * 
	 * @param overScrollMode
	 *            The new over-scroll mode for this view.
	 * @return self
	 */
	public self overScroll(int overScrollMode) {
		for (X vaporView : members)
			vaporView.overScroll(overScrollMode);
		return (self) this;

	}

	/**
	 * Sets the padding. The view may add on the space required to display the
	 * scrollbars, depending on the style and visibility of the scrollbars. So
	 * the values returned from padLeft(), padTop(), padRight() and padBottom()
	 * may be different from the values set in this call.
	 * 
	 * @param allSides
	 *            the padding in pixels to apply to top, left, bottom and right
	 *            sides
	 * @return self
	 */
	public self pad(int allSides) {
		return pad(allSides, allSides, allSides, allSides);
	}

	/**
	 * Sets the padding. The view may add on the space required to display the
	 * scrollbars, depending on the style and visibility of the scrollbars. So
	 * the values returned from padLeft(), padTop(), padRight() and padBottom()
	 * may be different from the values set in this call.
	 * 
	 * @param topBottom
	 *            the top and bottom padding in pixels
	 * @param leftRight
	 *            the left and right padding in pixels
	 * @return self
	 */
	public self pad(int topBottom, int leftRight) {
		return pad(leftRight, topBottom, leftRight, topBottom);
	}

	/**
	 * Sets the padding. The view may add on the space required to display the
	 * scrollbars, depending on the style and visibility of the scrollbars. So
	 * the values returned from padLeft(), padTop(), padRight() and padBottom()
	 * may be different from the values set in this call.
	 * 
	 * @param top
	 *            the top padding in pixels
	 * @param leftRight
	 *            the left and right padding in pixels
	 * @param bottom
	 *            the bottom padding in pixels
	 * @return self
	 */
	public self pad(int top, int leftRight, int bottom) {
		return pad(leftRight, top, leftRight, bottom);
	}

	/**
	 * Sets the padding. The view may add on the space required to display the
	 * scrollbars, depending on the style and visibility of the scrollbars. So
	 * the values returned from padLeft(), padTop(), padRight() and padBottom()
	 * may be different from the values set in this call.
	 * 
	 * @param left
	 *            the left padding in pixels
	 * @param top
	 *            the top padding in pixels
	 * @param right
	 *            the right padding in pixels
	 * @param bottom
	 *            the bottom padding in pixels
	 * @return self
	 */
	public self pad(int left, int top, int right, int bottom) {
		for (X vaporView : members)
			vaporView.pad(left, top, right, bottom);
		return (self) this;

	}

	/**
	 * Returns the bottom padding of this view.
	 * 
	 * @return the bottom padding in pixels
	 */
	public ArrayList<Integer> padBottom() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).padBottom());
		return _returns;
	}

	/**
	 * 
	 * @param bottom
	 * @return
	 */
	public self padBottom(int bottom) {
		for (X vaporView : members)
			vaporView.padBottom(bottom);
		return (self) this;
	}

	/**
	 * Returns the end padding of this view depending on its resolved layout
	 * direction. If there are inset and enabled scrollbars, this value may
	 * include the space required to display the scrollbars as well.
	 * 
	 * @return the end padding in pixels
	 */
	public ArrayList<Integer> padEnd() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).padEnd());
		return _returns;
	}

	/**
	 * Returns the left padding of this view.
	 * 
	 * @return the left padding in pixels
	 */
	public ArrayList<Integer> padLeft() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).padLeft());
		return _returns;
	}

	/**
	 * 
	 * @param left
	 * @return
	 */
	public self padLeft(int left) {
		for (X vaporView : members)
			vaporView.padLeft(left);
		return (self) this;
	}

	/**
	 * Return if the padding as been set thru relative values
	 * setPaddingRelative(int, int, int, int) or thru
	 * 
	 * @return true if the padding is relative or false if it is not.
	 */
	public ArrayList<Boolean> paddedRel() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).paddedRel());
		return _returns;
	}

	/**
	 * Sets the relative padding. The view may add on the space required to
	 * display the scrollbars, depending on the style and visibility of the
	 * scrollbars. So the values returned from padStart(), padTop(), padEnd()
	 * and padBottom() may be different from the values set in this call.
	 * 
	 * @param start
	 *            the start padding in pixels
	 * @param top
	 *            the top padding in pixels
	 * @param end
	 *            the end padding in pixels
	 * @param bottom
	 *            the bottom padding in pixels
	 * @return self
	 */
	public self padRel(int start, int top, int end, int bottom) {
		for (X vaporView : members)
			vaporView.padRel(start, top, end, bottom);
		return (self) this;

	}

	/**
	 * Sets the relative padding. The view may add on the space required to
	 * display the scrollbars, depending on the style and visibility of the
	 * scrollbars. So the values returned from padStart(), padTop(), padEnd()
	 * and padBottom() may be different from the values set in this call.
	 * 
	 * @param allSides
	 *            the relative padding to apply to top, left, bottom and right
	 *            sides
	 * @return self
	 */
	public self padRel(int allSides) {
		return padRel(allSides, allSides, allSides, allSides);
	}

	/**
	 * Sets the relative padding. The view may add on the space required to
	 * display the scrollbars, depending on the style and visibility of the
	 * scrollbars. So the values returned from padStart(), padTop(), padEnd()
	 * and padBottom() may be different from the values set in this call.
	 * 
	 * @param topBottom
	 *            the top and bottom relative padding in pixels
	 * @param startEnd
	 *            the start and end relative padding in pixels
	 * @return self
	 */
	public self padRel(int topBottom, int startEnd) {
		return padRel(startEnd, topBottom, startEnd, topBottom);
	}

	/**
	 * Sets the relative padding. The view may add on the space required to
	 * display the scrollbars, depending on the style and visibility of the
	 * scrollbars. So the values returned from padStart(), padTop(), padEnd()
	 * and padBottom() may be different from the values set in this call.
	 * 
	 * @param top
	 *            the top relative padding in pixels
	 * @param startEnd
	 *            the start and end relative padding in pixels
	 * @param bottom
	 *            the bottom relative padding in pixels
	 * @return self
	 */
	public self padRel(int top, int startEnd, int bottom) {
		return padRel(startEnd, top, startEnd, bottom);
	}

	/**
	 * Returns the right padding of this view.
	 * 
	 * @return the right padding in pixels
	 */
	public ArrayList<Integer> padRight() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).padRight());
		return _returns;
	}

	/**
	 * 
	 * @param right
	 * @return
	 */
	public self padRight(int right) {
		for (X vaporView : members)
			vaporView.padRight(right);
		return (self) this;
	}

	/**
	 * Returns the start padding of this view depending on its resolved layout
	 * direction. If there are inset and enabled scrollbars, this value may
	 * include the space required to display the scrollbars as well.
	 * 
	 * @return the start padding in pixels
	 */
	public ArrayList<Integer> padStart() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).padStart());
		return _returns;
	}

	/**
	 * Returns the top padding of this view.
	 * 
	 * @return the top padding in pixels
	 */
	public ArrayList<Integer> padTop() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).padTop());
		return _returns;
	}

	/**
	 * 
	 * @param top
	 * @return
	 */
	public self padTop(int top) {
		for (X vaporView : members)
			vaporView.padTop(top);
		return (self) this;
	}

	/**
	 * Gets the parent of this view. Note that the parent is a ViewParent and
	 * not necessarily a View.
	 * 
	 * @return parent of this view
	 */
	public final ArrayList<ViewParent> parent() {
		int _size = this.members.size();
		ArrayList<ViewParent> _returns = new ArrayList<ViewParent>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).parent());
		return _returns;
	}

	/**
	 * Gets the parent of this view.
	 * 
	 * @param forAccessibility
	 *            true to get the parent for accessibility purposes
	 * @return Parent of this view.
	 */
	public ArrayList<ViewParent> parent(boolean forAccessibility) {
		int _size = this.members.size();
		ArrayList<ViewParent> _returns = new ArrayList<ViewParent>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).parent(forAccessibility));
		return _returns;
	}

	/**
	 * Indicates whether the entire hierarchy under this view will save its
	 * state when a state saving traversal occurs from its parent.
	 * 
	 * @return Returns true if the view state saving from parent is enabled,
	 *         else false.
	 */
	public ArrayList<Boolean> parentSaveable() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).parentSaveable());
		return _returns;
	}

	/**
	 * Controls whether the entire hierarchy under this view will save its state
	 * when a state saving traversal occurs from its parent.
	 * 
	 * @param enabled
	 *            Set to false to disable state saving, or true (the default) to
	 *            allow it.
	 * @return self
	 */
	public self parentSaveable(boolean enabled) {
		for (X vaporView : members)
			vaporView.parentSaveable(enabled);
		return (self) this;

	}

	/**
	 * The x location of the point around which the view is rotated and scaled.
	 * 
	 * @return The x location of the pivot point.
	 */
	public ArrayList<Float> pivX() {
		int _size = this.members.size();
		ArrayList<Float> _returns = new ArrayList<Float>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).pivX());
		return _returns;
	}

	/**
	 * Sets the x location of the point around which the view is rotated and
	 * scaled.
	 * 
	 * @param pivotX
	 *            The x location of the pivot point.
	 * @return self
	 */
	public self pivX(float pivotX) {
		for (X vaporView : members)
			vaporView.pivX(pivotX);
		return (self) this;

	}

	/**
	 * The y location of the point around which the view is rotated and scaled.
	 * 
	 * @return The y location of the pivot point.
	 */
	public ArrayList<Float> pivY() {
		int _size = this.members.size();
		ArrayList<Float> _returns = new ArrayList<Float>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).pivY());
		return _returns;
	}

	/**
	 * Sets the y location of the point around which the view is rotated and
	 * scaled.
	 * 
	 * @param pivotY
	 *            The y location of the pivot point.
	 * @return self
	 */
	public self pivY(float pivotY) {
		for (X vaporView : members)
			vaporView.pivY(pivotY);
		return (self) this;

	}

	/**
	 * Equivalent fluent Vapor method for invoking
	 * onPopulateAccessibilityEvent(AccessibilityEvent), called from
	 * dispatchPopulateAccessibilityEvent(AccessibilityEvent) giving a chance to
	 * this View to populate the accessibility event with its text content.
	 * 
	 * @param accessibilityEvent
	 *            The accessibility event which to populate.
	 * @return self
	 */
	public self populateAccess(AccessibilityEvent accessibilityEvent) {
		for (X vaporView : members)
			vaporView.populateAccess(accessibilityEvent);
		return (self) this;

	}

	/**
	 * Computes the coordinates of this view.
	 * 
	 * @param location
	 * @param global
	 *            true returns coordinates on the screen, false returns
	 *            coordinates in its window
	 * @return
	 */
	public self pos(int[] location, boolean global) {
		for (X vaporView : members)
			vaporView.pos(location, global);
		return (self) this;

	}

	/**
	 * Causes the Runnable to be added to the message queue.
	 * 
	 * @param action
	 *            The Runnable that will be executed.
	 * @return Returns true if the Runnable was successfully placed in to the
	 *         message queue. Returns false on failure, usually because the
	 *         looper processing the message queue is exiting.
	 */
	public ArrayList<Boolean> post(Runnable action) {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).post(action));
		return _returns;
	}

	/**
	 * Causes the Runnable to be added to the message queue, to be run after the
	 * specified amount of time elapses.
	 * 
	 * @param action
	 *            The Runnable that will be executed.
	 * @param delayMillis
	 *            The delay (in milliseconds) until the Runnable will be
	 *            executed.
	 * @return true if the Runnable was successfully placed in to the message
	 *         queue. Returns false on failure, usually because the looper
	 *         processing the message queue is exiting. Note that a result of
	 *         true does not mean the Runnable will be processed -- if the
	 *         looper is quit before the delivery time of the message occurs
	 *         then the message will be dropped.
	 */
	public ArrayList<Boolean> post(Runnable action, long delayMillis) {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).post(action, delayMillis));
		return _returns;
	}

	/**
	 * Causes the Runnable to execute on the next animation time step.
	 * 
	 * @param action
	 *            Causes the Runnable to execute on the next animation time
	 *            step. The runnable will be run on the user interface thread.
	 * @return self
	 */
	public self postAnim(Runnable action) {
		for (X vaporView : members)
			vaporView.postAnim(action);
		return (self) this;

	}

	/**
	 * Causes the Runnable to execute on the next animation time step, after the
	 * specified amount of time elapses.
	 * 
	 * @param action
	 *            The Runnable that will be executed.
	 * @param delayMillis
	 *            The delay (in milliseconds) until the Runnable will be
	 *            executed.
	 * @return self
	 */
	public self postAnim(Runnable action, long delayMillis) {
		for (X vaporView : members)
			vaporView.postAnim(action, delayMillis);
		return (self) this;

	}

	/**
	 * Cause an invalidate to happen on the next animation time step, typically
	 * the next display frame.
	 * 
	 * @return self
	 */
	public self postAnimInvalidate() {
		for (X vaporView : members)
			vaporView.postAnimInvalidate();
		return (self) this;

	}

	/**
	 * Cause an invalidate of the specified area to happen on the next animation
	 * time step, typically the next display frame.
	 * 
	 * @param left
	 *            The left coordinate of the rectangle to invalidate.
	 * @param top
	 *            The top coordinate of the rectangle to invalidate.
	 * @param right
	 *            The right coordinate of the rectangle to invalidate.
	 * @param bottom
	 *            The bottom coordinate of the rectangle to invalidate.
	 * @return self
	 */
	public self postAnimInvalidate(int left, int top, int right, int bottom) {
		for (X vaporView : members)
			vaporView.postAnimInvalidate(left, top, right, bottom);
		return (self) this;

	}

	/**
	 * Cause an invalidate to happen on a subsequent cycle through the event
	 * loop.
	 * 
	 * @return self
	 */
	public self postInvalidate() {
		for (X vaporView : members)
			vaporView.postInvalidate();
		return (self) this;

	}

	/**
	 * Cause an invalidate to happen on a subsequent cycle through the event
	 * loop.
	 * 
	 * @param delayMilliseconds
	 *            the duration in milliseconds to delay the invalidation by
	 * @return self
	 */
	public self postInvalidate(long delayMilliseconds) {
		for (X vaporView : members)
			vaporView.postInvalidate(delayMilliseconds);
		return (self) this;

	}

	/**
	 * Cause an invalidate of the specified area to happen on a subsequent cycle
	 * through the event loop.
	 * 
	 * @param left
	 *            The left coordinate of the rectangle to invalidate.
	 * @param top
	 *            The top coordinate of the rectangle to invalidate.
	 * @param right
	 *            The right coordinate of the rectangle to invalidate.
	 * @param bottom
	 *            The bottom coordinate of the rectangle to invalidate.
	 * @return self
	 */
	public self postInvalidate(int left, int top, int right, int bottom) {
		for (X vaporView : members)
			vaporView.postInvalidate(left, top, right, bottom);
		return (self) this;

	}

	/**
	 * Cause an invalidate of the specified area to happen on a subsequent cycle
	 * through the event loop.
	 * 
	 * @param delayMilliseconds
	 *            the duration in milliseconds to delay the invalidation by
	 * @param left
	 *            The left coordinate of the rectangle to invalidate.
	 * @param top
	 *            The top coordinate of the rectangle to invalidate.
	 * @param right
	 *            The right coordinate of the rectangle to invalidate.
	 * @param bottom
	 *            The bottom coordinate of the rectangle to invalidate.
	 * @return self
	 */
	public self postInvalidate(long delayMilliseconds, int left, int top,
			int right, int bottom) {
		for (X vaporView : members)
			vaporView.postInvalidate(delayMilliseconds, left, top, right,
					bottom);
		return (self) this;

	}

	/**
	 * Indicates whether the view is currently in pressed state.
	 * 
	 * @return true if the view is currently pressed, false otherwise
	 */
	public ArrayList<Boolean> pressed() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).pressed());
		return _returns;
	}

	/**
	 * Sets the pressed state for this view.
	 * 
	 * @param pressed
	 *            Pass true to set the View's internal state to "pressed", or
	 *            false to reverts the View's internal state from a previously
	 *            set "pressed" state.
	 * @return self
	 */
	public self pressed(boolean pressed) {
		for (X vaporView : members)
			vaporView.pressed(pressed);
		return (self) this;

	}

	/**
	 * Equivalent fluent Vapor method for invoking
	 * checkInputConnectionProxy(View), called by the InputMethodManager when a
	 * view who is not the current input connection target is trying to make a
	 * call on the manager.
	 * 
	 * @param view
	 *            The View that is making the InputMethodManager call.
	 * @return Return true to allow the call, false to reject.
	 */
	public ArrayList<Boolean> proxy(VaporView<? extends View, ?> view) {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).proxy(view));
		return _returns;
	}

	/**
	 * Returns the resources associated with this view.
	 * 
	 * @return Resources object.
	 */
	public ArrayList<Resources> res() {
		int _size = this.members.size();
		ArrayList<Resources> _returns = new ArrayList<Resources>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).res());
		return _returns;
	}

	/**
	 * If some part of this view is not clipped by any of its parents, then
	 * return that area in r in global (root) coordinates.
	 * 
	 * @param rect
	 *            If true is returned, r holds the global coordinates of the
	 *            visible portion of this view.
	 * @return true if rect is non-empty (i.e. part of the view is visible at
	 *         the root level.)
	 */
	public ArrayList<Boolean> rect(Rect rect) {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).rect(rect));
		return _returns;
	}

	/**
	 * If some part of this view is not clipped by any of its parents, then
	 * return that area in r in global (root) coordinates.
	 * 
	 * @param rect
	 *            If true is returned, r holds the global coordinates of the
	 *            visible portion of this view.
	 * @param globalOffset
	 *            If true is returned, globalOffset holds the dx,dy between this
	 *            view and its root. globalOffet may be null.
	 * @return true if rect is non-empty (i.e. part of the view is visible at
	 *         the root level.)
	 */
	public ArrayList<Boolean> rect(Rect rect, Point globalOffset) {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).rect(rect, globalOffset));
		return _returns;
	}

	/**
	 * Call this to force a view to update its drawable state.
	 * 
	 * @return self
	 */
	public self refresh() {
		for (X vaporView : members)
			vaporView.refresh();
		return (self) this;

	}

	/**
	 * Removes the specified Runnable from the message queue.
	 * 
	 * @param callbackAction
	 *            The Runnable to remove from the message handling queue
	 * @return true if this view could ask the Handler to remove the Runnable,
	 *         false otherwise. When the returned value is true, the Runnable
	 *         may or may not have been actually removed from the message queue
	 *         (for instance, if the Runnable was not in the queue already.)
	 */
	public ArrayList<Boolean> remove(Runnable callbackAction) {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).remove(callbackAction));
		return _returns;
	}

	/**
	 * Remove a listener for attach state changes.
	 * 
	 * @param attachStateChangeListener
	 *            Listener to remove
	 * @return self
	 */
	public self remove(OnAttachStateChangeListener attachStateChangeListener) {
		for (X vaporView : members)
			vaporView.remove(attachStateChangeListener);
		return (self) this;

	}

	/**
	 * Remove a listener for layout changes.
	 * 
	 * @param layoutChangeListener
	 *            The listener for layout bounds change.
	 * @return self
	 */
	public self remove(OnLayoutChangeListener layoutChangeListener) {
		for (X vaporView : members)
			vaporView.remove(layoutChangeListener);
		return (self) this;

	}

	/**
	 * Ask that a new dispatch of fitSystemWindows(Rect) be performed.
	 * 
	 * @return self
	 */
	public self reqFit() {
		for (X vaporView : members)
			vaporView.reqFit();
		return (self) this;

	}

	/**
	 * Call this to try to give focus to a specific view or to one of its
	 * descendants.
	 * 
	 * @return Whether this view or one of its descendants actually took focus.
	 */
	public ArrayList<Boolean> reqFocus() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).reqFocus());
		return _returns;
	}

	/**
	 * Call this to try to give focus to a specific view or to one of its
	 * descendants and give it a hint about what direction focus is heading.
	 * 
	 * @param direction
	 *            One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT
	 * @return Whether this view or one of its descendants actually took focus.
	 */
	public final ArrayList<Boolean> reqFocus(int direction) {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).reqFocus(direction));
		return _returns;
	}

	/**
	 * Call this to try to give focus to a specific view or to one of its
	 * descendants and give it hints about the direction and a specific
	 * rectangle that the focus is coming from.
	 * 
	 * @param direction
	 *            One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT
	 * @param previouslyFocusedRect
	 *            The rectangle (in this View's coordinate system) to give a
	 *            finer grained hint about where focus is coming from. May be
	 *            null if there is no hint.
	 * @return Whether this view or one of its descendants actually took focus.
	 */
	public final ArrayList<Boolean> reqFocus(int direction,
			Rect previouslyFocusedRect) {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).reqFocus(direction,
					previouslyFocusedRect));
		return _returns;
	}

	/**
	 * Call this to try to give focus to a specific view or to one of its
	 * descendants.
	 * 
	 * @return Whether this view or one of its descendants actually took focus.
	 */
	public final ArrayList<Boolean> reqTouchFocus() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).reqTouchFocus());
		return _returns;
	}

	/**
	 * Call this when something has changed which has invalidated the layout of
	 * this view.
	 * 
	 * @return self
	 */
	public self reqLayout() {
		for (X vaporView : members)
			vaporView.reqLayout();
		return (self) this;

	}

	/**
	 * Request that a rectangle of this view be visible on the screen, scrolling
	 * if necessary just enough.
	 * 
	 * @param rectangle
	 *            The rectangle.
	 * @return Whether any parent scrolled.
	 */
	public ArrayList<Boolean> reqRect(Rect rectangle) {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).reqRect(rectangle));
		return _returns;
	}

	/**
	 * Request that a rectangle of this view be visible on the screen, scrolling
	 * if necessary just enough.
	 * 
	 * @param rectangle
	 *            The rectangle.
	 * @param immediate
	 *            True to forbid animated scrolling, false otherwise
	 * @return Whether any parent scrolled.
	 */
	public ArrayList<Boolean> reqRect(Rect rectangle, boolean immediate) {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).reqRect(rectangle, immediate));
		return _returns;
	}

	/**
	 * Version of resolveSizeAndState(int, int, int) returning only the
	 * MEASURED_SIZE_MASK bits of the result.
	 * 
	 * @param size
	 *            How big the view wants to be
	 * @param measureSpec
	 *            Constraints imposed by the parent
	 * @return
	 */
	public static int resolve(int size, int measureSpec) {
		return View.resolveSize(size, measureSpec);
	}

	/**
	 * Utility to reconcile a desired size and state, with constraints imposed
	 * by a MeasureSpec.
	 * 
	 * @param size
	 *            How big the view wants to be
	 * @param measureSpec
	 *            Constraints imposed by the parent
	 * @param childMeasuredState
	 * @return Size information bit mask as defined by MEASURED_SIZE_MASK and
	 *         MEASURED_STATE_TOO_SMALL.
	 */
	public static int resolve(int size, int measureSpec, int childMeasuredState) {
		return View.resolveSizeAndState(size, measureSpec, childMeasuredState);
	}

	/**
	 * Restore this view hierarchy's frozen state from the given container.
	 * 
	 * @param frozenHierarchyContainer
	 *            The SparseArray which holds previously frozen states.
	 * @return self
	 */
	public self restore(SparseArray<Parcelable> frozenHierarchyContainer) {
		for (X vaporView : members)
			vaporView.restore(frozenHierarchyContainer);
		return (self) this;

	}

	/**
	 * Right position of this view relative to its parent.
	 * 
	 * @return The right edge of this view, in pixels.
	 */
	public final ArrayList<Integer> right() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).right());
		return _returns;
	}

	/**
	 * Sets the right position of this view relative to its parent.
	 * 
	 * @param right
	 *            The right of this view, in pixels.
	 * @return self
	 */
	public self right(int right) {
		for (X vaporView : members)
			vaporView.right(right);
		return (self) this;

	}

	/**
	 * Finds the topmost view in the current view hierarchy.
	 * 
	 * @return the topmost view containing this view
	 */
	public ArrayList<View> root() {
		int _size = this.members.size();
		ArrayList<View> _returns = new ArrayList<View>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).root());
		return _returns;
	}

	/**
	 * The degrees that the view is rotated around the pivot point.
	 * 
	 * @return The degrees of rotation.
	 */
	public ArrayList<Float> rot() {
		int _size = this.members.size();
		ArrayList<Float> _returns = new ArrayList<Float>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).rot());
		return _returns;
	}

	/**
	 * Sets the degrees that the view is rotated around the pivot point.
	 * 
	 * @param rotation
	 *            The degrees of rotation.
	 * @return self
	 */
	public self rot(float rotation) {
		for (X vaporView : members)
			vaporView.rot(rotation);
		return (self) this;

	}

	/**
	 * The degrees that the view is rotated around the horizontal axis through
	 * the pivot point.
	 * 
	 * @return The degrees of X rotation.
	 */
	public ArrayList<Float> rotX() {
		int _size = this.members.size();
		ArrayList<Float> _returns = new ArrayList<Float>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).rotX());
		return _returns;
	}

	/**
	 * Sets the degrees that the view is rotated around the horizontal axis
	 * through the pivot point.
	 * 
	 * @param rotationX
	 *            The degrees of X rotation.
	 * @return self
	 */
	public self rotX(float rotationX) {
		for (X vaporView : members)
			vaporView.rotX(rotationX);
		return (self) this;

	}

	/**
	 * The degrees that the view is rotated around the vertical axis through the
	 * pivot point.
	 * 
	 * @return The degrees of Y rotation.
	 */
	public ArrayList<Float> rotY() {
		int _size = this.members.size();
		ArrayList<Float> _returns = new ArrayList<Float>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).rotY());
		return _returns;
	}

	/**
	 * Sets the degrees that the view is rotated around the vertical axis
	 * through the pivot point.
	 * 
	 * @param rotationY
	 *            The degrees of Y rotation.
	 * @return self
	 */
	public self rotY(float rotationY) {
		for (X vaporView : members)
			vaporView.rotY(rotationY);
		return (self) this;

	}

	/**
	 * Fluent equivalent Vapor method for invoking onRtlPropertiesChanged(int),
	 * called when any RTL property (layout direction or text direction or text
	 * alignment) has been changed.
	 * 
	 * @param layoutDirection
	 *            the direction of the layout
	 * @return self
	 */
	public self rtlPropChanged(int layoutDirection) {
		for (X vaporView : members)
			vaporView.rtlPropChanged(layoutDirection);
		return (self) this;

	}

	/**
	 * Store this view hierarchy's frozen state into the given container.
	 * 
	 * @param frozenHierarchyContainer
	 *            The SparseArray in which to save the view's state.
	 * @return self
	 */
	public self save(SparseArray<Parcelable> frozenHierarchyContainer) {
		for (X vaporView : members)
			vaporView.save(frozenHierarchyContainer);
		return (self) this;

	}

	/**
	 * Indicates whether this view will save its state (that is, whether its
	 * save() method will be called).
	 * 
	 * @return Returns true if the view state saving is enabled, else false.
	 */
	public ArrayList<Boolean> saveable() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).saveable());
		return _returns;
	}

	/**
	 * Controls whether the saving of this view's state is enabled (that is,
	 * whether its onSaveInstanceState() method will be called).
	 * 
	 * @param enabled
	 *            Set to false to disable state saving, or true (the default) to
	 *            allow it.
	 * @return self
	 */
	public self saveable(boolean enabled) {
		for (X vaporView : members)
			vaporView.saveable(enabled);
		return (self) this;

	}

	/**
	 * The amount that the view is scaled in x around the pivot point, as a
	 * proportion of the view's unscaled width.
	 * 
	 * @return The scaling factor.
	 */
	public ArrayList<Float> scaleX() {
		int _size = this.members.size();
		ArrayList<Float> _returns = new ArrayList<Float>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).scaleX());
		return _returns;
	}

	/**
	 * Sets the amount that the view is scaled in x around the pivot point, as a
	 * proportion of the view's unscaled width.
	 * 
	 * @param scaleX
	 *            The scaling factor.
	 * @return self
	 */
	public self scaleX(float scaleX) {
		for (X vaporView : members)
			vaporView.scaleX(scaleX);
		return (self) this;

	}

	/**
	 * The amount that the view is scaled in y around the pivot point, as a
	 * proportion of the view's unscaled height.
	 * 
	 * @return The scaling factor.
	 */
	public ArrayList<Float> scaleY() {
		int _size = this.members.size();
		ArrayList<Float> _returns = new ArrayList<Float>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).scaleY());
		return _returns;
	}

	/**
	 * Sets the amount that the view is scaled in Y around the pivot point, as a
	 * proportion of the view's unscaled width.
	 * 
	 * @param scaleY
	 *            The scaling factor.
	 * @return self
	 */
	public self scaleY(float scaleY) {
		for (X vaporView : members)
			vaporView.scaleY(scaleY);
		return (self) this;

	}

	/**
	 * Equivalent fluent Vapor method for invoking
	 * scheduleDrawable(Drawable,Runnable,long), schedules an action on a
	 * drawable to occur at a specified time.
	 * 
	 * @param drawable
	 *            the recipient of the action
	 * @param runnable
	 *            the action to run on the drawable
	 * @param when
	 *            the time at which the action must occur. Uses the
	 * @return self
	 */
	public self sched(Drawable drawable, Runnable runnable, long when) {
		for (X vaporView : members)
			vaporView.sched(drawable, runnable, when);
		return (self) this;

	}

	/**
	 * Fluent equivalent Vapor method for invoking onScreenStateChanged(int),
	 * called whenever the state of the screen this view is attached to changes.
	 * 
	 * @param screenState
	 *            The new state of the screen. Can be either SCREEN_STATE_ON or
	 *            SCREEN_STATE_OFF
	 * @return self
	 */
	public self screenChanged(int screenState) {
		for (X vaporView : members)
			vaporView.screenChanged(screenState);
		return (self) this;

	}

	/**
	 * Called by a parent to request that a child update its values for mScrollX
	 * and mScrollY if necessary.
	 * 
	 * @return self
	 */
	public self scroll() {
		for (X vaporView : members)
			vaporView.scroll();
		return (self) this;

	}

	/**
	 * Indicates whether this view is one of the set of scrollable containers in
	 * its window.
	 * 
	 * @return whether this view is one of the set of scrollable containers in
	 *         its window
	 */
	public ArrayList<Boolean> scrollable() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).scrollable());
		return _returns;
	}

	/**
	 * Change whether this view is one of the set of scrollable containers in
	 * its window.
	 * 
	 * @param isScrollContainer
	 * @return self
	 */
	public self scrollable(boolean isScrollContainer) {
		for (X vaporView : members)
			vaporView.scrollable(isScrollContainer);
		return (self) this;

	}

	/**
	 * Move the scrolled position of your view. This will cause a call to
	 * onScrollChanged(int, int, int, int) and the view will be invalidated.
	 * 
	 * @param x
	 *            the amount of pixels to scroll by horizontally
	 * @param y
	 *            the amount of pixels to scroll by vertically
	 * @return self
	 */
	public self scrollBy(int x, int y) {
		for (X vaporView : members)
			vaporView.scrollBy(x, y);
		return (self) this;

	}

	/**
	 * Returns the scrollbar fade duration.
	 * 
	 * @return the scrollbar fade duration
	 */
	public ArrayList<Integer> scrollFade() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).scrollFade());
		return _returns;
	}

	/**
	 * Defines the scrollbar fade duration.
	 * 
	 * @param scrollBarFadeDuration
	 *            the scrollbar fade duration
	 * @return self
	 */
	public self scrollFade(int scrollBarFadeDuration) {
		for (X vaporView : members)
			vaporView.scrollFade(scrollBarFadeDuration);
		return (self) this;

	}

	/**
	 * Define whether scrollbars will fade when the view is not scrolling.
	 * 
	 * @param fadeScrollBars
	 *            wheter to enable fading
	 * @return self
	 */
	public self scrollsFade(boolean fadeScrollBars) {
		for (X vaporView : members)
			vaporView.scrollsFade(fadeScrollBars);
		return (self) this;

	}

	/**
	 * Returns the delay before scrollbars fade.
	 * 
	 * @return the delay before scrollbars fade
	 */
	public ArrayList<Integer> scrollPreFade() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).scrollPreFade());
		return _returns;
	}

	/**
	 * Define the delay before scrollbars fade.
	 * 
	 * @param scrollBarDefaultDelayBeforeFade
	 *            the delay before scrollbars fade
	 * @return self
	 */
	public self scrollPreFade(int scrollBarDefaultDelayBeforeFade) {
		for (X vaporView : members)
			vaporView.scrollPreFade(scrollBarDefaultDelayBeforeFade);
		return (self) this;

	}

	/**
	 * Returns the scrollbar size.
	 * 
	 * @return the scrollbar size
	 */
	public ArrayList<Integer> scrollSize() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).scrollSize());
		return _returns;
	}

	/**
	 * Define the scrollbar size.
	 * 
	 * @param scrollBarSize
	 *            the scrollbar size
	 * @return self
	 */
	public self scrollSize(int scrollBarSize) {
		for (X vaporView : members)
			vaporView.scrollSize(scrollBarSize);
		return (self) this;

	}

	/**
	 * Returns the current scrollbar style.
	 * 
	 * @return the current scrollbar style
	 */
	public ArrayList<Integer> scrollStyle() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).scrollStyle());
		return _returns;
	}

	/**
	 * Specify the style of the scrollbars.
	 * 
	 * @param scrollBarStyle
	 *            the style of the scrollbars. Should be one of
	 *            SCROLLBARS_INSIDE_OVERLAY, SCROLLBARS_INSIDE_INSET,
	 *            SCROLLBARS_OUTSIDE_OVERLAY or SCROLLBARS_OUTSIDE_INSET.
	 * @return self
	 */
	public self scrollStyle(int scrollBarStyle) {
		for (X vaporView : members)
			vaporView.scrollStyle(scrollBarStyle);
		return (self) this;

	}

	/**
	 * Move the scrolled position of your view. This will cause a call to
	 * scrollChanged(int, int, int, int) and the view will be invalidated.
	 * 
	 * @param x
	 *            the amount of pixels to scroll by horizontally
	 * @param y
	 *            the amount of pixels to scroll by vertically
	 * @return self
	 */
	public self scrollTo(int x, int y) {
		for (X vaporView : members)
			vaporView.scrollTo(x, y);
		return (self) this;

	}

	/**
	 * Return the scrolled left position of this view.
	 * 
	 * @return The left edge of the displayed part of your view, in pixels.
	 */
	public final ArrayList<Integer> scrollX() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).scrollX());
		return _returns;
	}

	/**
	 * Set the horizontal scrolled position of your view.
	 * 
	 * @param scrollX
	 *            the x position to scroll to
	 * @return
	 */
	public self scrollX(int scrollX) {
		for (X vaporView : members)
			vaporView.scrollX(scrollX);
		return (self) this;

	}

	/**
	 * Return the scrolled top position of this view.
	 * 
	 * @return The top edge of the displayed part of your view, in pixels.
	 */
	public final ArrayList<Integer> scrollY() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).scrollY());
		return _returns;
	}

	/**
	 * Set the vertical scrolled position of your view.
	 * 
	 * @param scrollY
	 *            the y position to scroll to
	 * @return self
	 */
	public self scrollY(int scrollY) {
		for (X vaporView : members)
			vaporView.scrollY(scrollY);
		return (self) this;

	}

	/**
	 * Fluent equivalent Vapor method for invoking
	 * onFilterTouchEventForSecurity(MotionEvent), used to filter the touch
	 * event to apply security policies.
	 * 
	 * @param motionEvent
	 *            The motion event to be filtered.
	 * @return True if the event should be dispatched, false if the event should
	 *         be dropped.
	 */
	public ArrayList<Boolean> secTouchFilter(MotionEvent motionEvent) {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).secTouchFilter(motionEvent));
		return _returns;
	}

	/**
	 * Indicates the selection state of this view.
	 * 
	 * @return true if the view is selected, false otherwise
	 */
	public ArrayList<Boolean> selected() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).selected());
		return _returns;
	}

	/**
	 * Changes the selection state of this view.
	 * 
	 * @param selected
	 *            true if the view must be selected, false otherwise
	 * @return self
	 */
	public self selected(boolean selected) {
		for (X vaporView : members)
			vaporView.selected(selected);
		return (self) this;

	}

	/**
	 * Equivalent fluent Vapor method for invoking sendAccessibilityEvent(int),
	 * sends an accessibility event of the given type.
	 * 
	 * @param accessibilityEventType
	 *            The type of the event to send, as defined by several types
	 *            from AccessibilityEvent, such as TYPE_VIEW_CLICKED or
	 *            TYPE_VIEW_HOVER_ENTER.
	 * @return self
	 */
	public self sendAccess(int accessibilityEventType) {
		for (X vaporView : members)
			vaporView.sendAccess(accessibilityEventType);
		return (self) this;

	}

	/**
	 * Equivalent fluent Vapor method for invoking
	 * sendAccessibilityEventUnchecked(AccessibilityEvent), this method behaves
	 * exactly as sendAccessibilityEvent(int) but takes as an argument an empty
	 * AccessibilityEvent and does not perform a check whether accessibility is
	 * enabled.
	 * 
	 * @param accessibilityEvent
	 * @return self
	 */
	public self sendUncheckedAccess(AccessibilityEvent accessibilityEvent) {
		for (X vaporView : members)
			vaporView.sendUncheckedAccess(accessibilityEvent);
		return (self) this;

	}

	/**
	 * Play a sound effect for this view.
	 * 
	 * @param soundConstant
	 *            One of the constants defined in SoundEffectConstants
	 * @return self
	 */
	public self sfx(int soundConstant) {
		for (X vaporView : members)
			vaporView.sfx(soundConstant);
		return (self) this;

	}

	/**
	 * 
	 * @return whether this view should have sound effects enabled for events
	 *         such as clicking and touching.
	 */
	public ArrayList<Boolean> sfxable() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).sfxable());
		return _returns;
	}

	/**
	 * Set whether this view should have sound effects enabled for events such
	 * as clicking and touching.
	 * 
	 * @param soundEffectsEnabled
	 *            whether sound effects are enabled for this view.
	 * @return self
	 */
	public self sfxable(boolean soundEffectsEnabled) {
		for (X vaporView : members)
			vaporView.sfxable(soundEffectsEnabled);
		return (self) this;

	}

	/**
	 * Returns the visibility of this view and all of its ancestors
	 * 
	 * @return True if this view and all of its ancestors are VISIBLE
	 */
	public ArrayList<Boolean> showing() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).showing());
		return _returns;
	}

	/**
	 * Override this if your view is known to always be drawn on top of a solid
	 * color background, and needs to draw fading edges.
	 * 
	 * @return The known solid color background for this view, or 0 if the color
	 *         may vary
	 */
	public ArrayList<Integer> solColor() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).solColor());
		return _returns;
	}

	/**
	 * Start the specified animation now.
	 * 
	 * @param animation
	 *            the animation to start now
	 * @return self
	 */
	public self startAnim(Animation animation) {
		for (X vaporView : members)
			vaporView.startAnim(animation);
		return (self) this;

	}

	/**
	 * Fluent equivalent Vapor method for invoking onStartTemporaryDetach(),
	 * called when a container is going to temporarily detach a child, with
	 * ViewGroup.detachViewFromParent.
	 * 
	 * @return self
	 */
	public self tempDetach() {
		for (X vaporView : members)
			vaporView.tempDetach();
		return (self) this;

	}

	/**
	 * Add a listener for attach state changes.
	 * 
	 * @param attachStateListener
	 *            Listener to attach.
	 * @return self
	 */
	public self state(vapor.listeners.view.$state attachStateListener) {
		for (X vaporView : members)
			vaporView.state(attachStateListener);
		return (self) this;

	}

	/**
	 * Returns the last sysViz(int) that this view has requested.
	 * 
	 * @return Bitwise-or of flags SYSTEM_UI_FLAG_LOW_PROFILE,
	 *         SYSTEM_UI_FLAG_HIDE_NAVIGATION, SYSTEM_UI_FLAG_FULLSCREEN,
	 *         SYSTEM_UI_FLAG_LAYOUT_STABLE,
	 *         SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION, and
	 *         SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN.
	 */
	public ArrayList<Integer> sysViz() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).sysViz());
		return _returns;
	}

	/**
	 * Request that the visibility of the status bar or other screen/window
	 * decorations be changed.
	 * 
	 * @param systemUiVisibility
	 *            Bitwise-or of flags SYSTEM_UI_FLAG_LOW_PROFILE,
	 *            SYSTEM_UI_FLAG_HIDE_NAVIGATION, SYSTEM_UI_FLAG_FULLSCREEN,
	 *            SYSTEM_UI_FLAG_LAYOUT_STABLE,
	 *            SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION, and
	 *            SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN.
	 * @return self
	 */
	public self sysViz(int systemUiVisibility) {
		for (X vaporView : members)
			vaporView.sysViz(systemUiVisibility);
		return (self) this;

	}

	/**
	 * Set a listener to receive callbacks when the visibility of the system bar
	 * changes.
	 * 
	 * @param systemUiVisibilityChangeListener
	 *            The View.OnSystemUiVisibilityChangeListener to receive
	 *            callbacks.
	 * @return self
	 */
	public self sysViz(
			vapor.listeners.view.$change systemUiVisibilityChangeListener) {
		for (X vaporView : members)
			vaporView.sysViz(systemUiVisibilityChangeListener);
		return (self) this;

	}

	/**
	 * Returns this view's tag.
	 * 
	 * @return the Object stored in this view as a tag
	 */
	public ArrayList<Object> tag() {
		int _size = this.members.size();
		ArrayList<Object> _returns = new ArrayList<Object>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).tag());
		return _returns;
	}

	/**
	 * Returns the tag associated with this view and the specified key.
	 * 
	 * @param key
	 *            The key identifying the tag
	 * @return the Object stored in this view as a tag
	 */
	public ArrayList<Object> tag(int key) {
		int _size = this.members.size();
		ArrayList<Object> _returns = new ArrayList<Object>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).tag(key));
		return _returns;
	}

	/**
	 * Sets the tag associated with this view.
	 * 
	 * @param tag
	 *            an Object to tag the view with
	 * @return self
	 */
	public self tag(Object tag) {
		for (X vaporView : members)
			vaporView.tag(tag);
		return (self) this;

	}

	/**
	 * Sets a tag associated with this view and a key.
	 * 
	 * @param key
	 *            The key identifying the tag
	 * @param tag
	 *            An Object to tag the view with
	 * @return self
	 */
	public self tag(int key, Object tag) {
		for (X vaporView : members)
			vaporView.tag(key, tag);
		return (self) this;

	}

	/**
	 * Return the resolved text alignment.
	 * 
	 * @return the resolved text alignment. Returns one of:
	 *         TEXT_ALIGNMENT_GRAVITY, TEXT_ALIGNMENT_CENTER,
	 *         TEXT_ALIGNMENT_TEXT_START, TEXT_ALIGNMENT_TEXT_END,
	 *         TEXT_ALIGNMENT_VIEW_START, TEXT_ALIGNMENT_VIEW_END
	 */
	public ArrayList<Integer> textAlignment() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).textAlignment());
		return _returns;
	}

	/**
	 * Set the text alignment.
	 * 
	 * @param textAlignment
	 *            The text alignment to set. Should be one of
	 *            TEXT_ALIGNMENT_INHERIT, TEXT_ALIGNMENT_GRAVITY,
	 *            TEXT_ALIGNMENT_CENTER, TEXT_ALIGNMENT_TEXT_START,
	 *            TEXT_ALIGNMENT_TEXT_END, TEXT_ALIGNMENT_VIEW_START,
	 *            TEXT_ALIGNMENT_VIEW_END Resolution will be done if the value
	 *            is set to TEXT_ALIGNMENT_INHERIT. The resolution proceeds up
	 *            the parent chain of the view to get the value. If there is no
	 *            parent, then it will return the default
	 *            TEXT_ALIGNMENT_GRAVITY.
	 * @return self
	 */
	public self textAlignment(int textAlignment) {
		for (X vaporView : members)
			vaporView.textAlignment(textAlignment);
		return (self) this;

	}

	/**
	 * Return the resolved text direction.
	 * 
	 * @return the resolved text direction. Returns one of:
	 *         TEXT_DIRECTION_FIRST_STRONG TEXT_DIRECTION_ANY_RTL,
	 *         TEXT_DIRECTION_LTR, TEXT_DIRECTION_RTL, TEXT_DIRECTION_LOCALE
	 */
	public ArrayList<Integer> textDirection() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).textDirection());
		return _returns;
	}

	/**
	 * Set the text direction.
	 * 
	 * @param textDirection
	 *            the direction to set. Should be one of:
	 *            TEXT_DIRECTION_INHERIT, TEXT_DIRECTION_FIRST_STRONG
	 *            TEXT_DIRECTION_ANY_RTL, TEXT_DIRECTION_LTR,
	 *            TEXT_DIRECTION_RTL, TEXT_DIRECTION_LOCALE Resolution will be
	 *            done if the value is set to TEXT_DIRECTION_INHERIT. The
	 *            resolution proceeds up the parent chain of the view to get the
	 *            value. If there is no parent, then it will return the default
	 *            TEXT_DIRECTION_FIRST_STRONG.
	 * @return self
	 */
	public self textDirection(int textDirection) {
		for (X vaporView : members)
			vaporView.textDirection(textDirection);
		return (self) this;

	}

	/**
	 * Fluent equivalent Vapor method for invoking onCheckIsTextEditor(), used
	 * to check whether the called view is a text editor, in which case it would
	 * make sense to automatically display a soft input window for it.
	 * 
	 * @return Returns true if this view is a text editor, else false.
	 */
	public ArrayList<Boolean> textEditor() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).textEditor());
		return _returns;
	}

	/**
	 * Retrieve a unique token identifying the window that this view is attached
	 * to.
	 * 
	 * @param applicationWindowToken
	 *            true returns the top-level "real" window of the window that
	 *            this view is attached to.
	 * @return Returns the associated window token, either getWindowToken() or
	 *         the containing window's token.
	 */
	public ArrayList<IBinder> token(boolean applicationWindowToken) {
		int _size = this.members.size();
		ArrayList<IBinder> _returns = new ArrayList<IBinder>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).token(applicationWindowToken));
		return _returns;
	}

	/**
	 * Top position of this view relative to its parent.
	 * 
	 * @return The top of this view, in pixels.
	 */
	public final ArrayList<Integer> top() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).top());
		return _returns;
	}

	/**
	 * Sets the top position of this view relative to its parent.
	 * 
	 * @param top
	 *            The top of this view, in pixels.
	 * @return self
	 */
	public self top(int top) {
		for (X vaporView : members)
			vaporView.top(top);
		return (self) this;

	}

	/**
	 * Fluent equivalent Vapor method for invoking onTouchEvent(MotionEvent),
	 * used to handle touch screen motion events.
	 * 
	 * @param touchEvent
	 *            The motion event.
	 * @return True if the event was handled, false otherwise.
	 */
	public ArrayList<Boolean> touch(MotionEvent touchEvent) {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).touch(touchEvent));
		return _returns;
	}

	/**
	 * Register a callback to be invoked when a touch event is sent to this
	 * view.
	 * 
	 * @param touchListener
	 *            the touch listener to attach to this view
	 * @return self
	 */
	public self touch(vapor.listeners.view.$touch touchListener) {
		for (X vaporView : members)
			vaporView.touch(touchListener);
		return (self) this;

	}

	/**
	 * Add any touchable views that are descendants of this view (possibly
	 * including this view if it is touchable itself) to views.
	 * 
	 * @param views
	 *            Touchable views found so far
	 * @return self
	 */
	public self touchables(ArrayList<VaporView<? extends View, ?>> views) {
		for (X vaporView : members)
			vaporView.touchables(views);
		return (self) this;

	}

	/**
	 * Returns whether the device is currently in touch mode.
	 * 
	 * @return Whether the device is in touch mode.
	 */
	public ArrayList<Boolean> touching() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).touching());
		return _returns;
	}

	/**
	 * Gets the TouchDelegate for this View.
	 * 
	 * @return the TouchDelegate for this View
	 */
	public ArrayList<TouchDelegate> touchDelegate() {
		int _size = this.members.size();
		ArrayList<TouchDelegate> _returns = new ArrayList<TouchDelegate>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).touchDelegate());
		return _returns;
	}

	/**
	 * Sets the TouchDelegate for this View.
	 * 
	 * @param touchDelegate
	 * @return self
	 */
	public self delegate(TouchDelegate touchDelegate) {
		for (X vaporView : members)
			vaporView.delegate(touchDelegate);
		return (self) this;

	}

	/**
	 * Sets a delegate for implementing accessibility support via compositon as
	 * opposed to inheritance.
	 * 
	 * @param accessibilityDelegate
	 *            The delegate instance.
	 * @return self
	 */
	public self delegate(AccessibilityDelegate accessibilityDelegate) {
		for (X vaporView : members)
			vaporView.delegate(accessibilityDelegate);
		return (self) this;

	}

	/**
	 * When a view is focusable, it may not want to take focus when in touch
	 * mode.
	 * 
	 * @return Whether the view is focusable in touch mode.
	 */
	public ArrayList<Boolean> touchFocusable() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).touchFocusable());
		return _returns;
	}

	/**
	 * Set whether this view can receive focus while in touch mode.
	 * 
	 * @param focusableInTouchMode
	 *            If true, this view can receive the focus while in touch mode.
	 * @returnn this
	 */
	public self touchFocusable(boolean focusableInTouchMode) {
		for (X vaporView : members)
			vaporView.touchFocusable(focusableInTouchMode);
		return (self) this;

	}

	/**
	 * Fluent equivalent Vapor method for invoking
	 * onTrackballEvent(MotionEvent), used to handle trackball motion events.
	 * 
	 * 
	 * @param trackballEvent
	 *            The motion event.
	 * @return True if the event was handled, false otherwise.
	 */
	public ArrayList<Boolean> trackball(MotionEvent trackballEvent) {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).trackball(trackballEvent));
		return _returns;
	}

	/**
	 * Indicates whether the view is currently tracking transient state that the
	 * app should not need to concern itself with saving and restoring, but that
	 * the framework should take special note to preserve when possible.
	 * 
	 * @return true if the view has transient state
	 */
	public ArrayList<Boolean> transientState() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).transientState());
		return _returns;
	}

	/**
	 * Set whether this view is currently tracking transient state that the
	 * framework should attempt to preserve when possible.
	 * 
	 * @param hasTransientState
	 *            true if this view has transient state
	 * @return self
	 */
	public self transientState(boolean hasTransientState) {
		for (X vaporView : members)
			vaporView.transientState(hasTransientState);
		return (self) this;

	}

	/**
	 * The horizontal location of this view relative to its left position.
	 * 
	 * @return The horizontal position of this view relative to its left
	 *         position, in pixels.
	 */
	public ArrayList<Float> transX() {
		int _size = this.members.size();
		ArrayList<Float> _returns = new ArrayList<Float>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).transX());
		return _returns;
	}

	/**
	 * Sets the horizontal location of this view relative to its left position.
	 * 
	 * @param translationX
	 *            The horizontal position of this view relative to its left
	 *            position, in pixels.
	 * @return self
	 */
	public self transX(float translationX) {
		for (X vaporView : members)
			vaporView.transX(translationX);
		return (self) this;

	}

	/**
	 * The horizontal location of this view relative to its top position.
	 * 
	 * @return The vertical position of this view relative to its top position,
	 *         in pixels.
	 */
	public ArrayList<Float> transY() {
		int _size = this.members.size();
		ArrayList<Float> _returns = new ArrayList<Float>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).transY());
		return _returns;
	}

	/**
	 * Sets the vertical location of this view relative to its top position.
	 * 
	 * @param translationY
	 *            The vertical position of this view relative to its top
	 *            position, in pixels.
	 * @return self
	 */
	public self transY(float translationY) {
		for (X vaporView : members)
			vaporView.transY(translationY);
		return (self) this;

	}

	/**
	 * Returns the ViewTreeObserver for this view's hierarchy.
	 * 
	 * @return The ViewTreeObserver for this view's hierarchy.
	 */
	public ArrayList<ViewTreeObserver> treeObserver() {
		int _size = this.members.size();
		ArrayList<ViewTreeObserver> _returns = new ArrayList<ViewTreeObserver>(
				_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).treeObserver());
		return _returns;
	}

	/**
	 * Equivalent fluent Vapor method for invoking unscheduleDrawable(Drawable),
	 * called to unschedule any events associated with the given Drawable.
	 * 
	 * @param drawable
	 *            The Drawable to unschedule.
	 * @return self
	 */
	public self unsched(Drawable drawable) {
		for (X vaporView : members)
			vaporView.unsched(drawable);
		return (self) this;

	}

	/**
	 * Equivalent fluent Vapor method for invoking unscheduleDrawable(Drawable),
	 * called to cancel a scheduled action on a drawable.
	 * 
	 * @param drawable
	 *            the recipient of the action
	 * @param runnable
	 *            the action to cancel
	 * @return self
	 */
	public self unsched(Drawable drawable, Runnable runnable) {
		for (X vaporView : members)
			vaporView.unsched(drawable, runnable);
		return (self) this;

	}

	/**
	 * Returns the width of the vertical scrollbar.
	 * 
	 * @return The width in pixels of the vertical scrollbar or 0 if there is no
	 *         vertical scrollbar.
	 */
	public ArrayList<Integer> yScrollWidth() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).yScrollWidth());
		return _returns;
	}

	/**
	 * Indicate whether the vertical edges are faded when the view is scrolled
	 * horizontally.
	 * 
	 * @return true if the vertical edges should are faded on scroll, false
	 *         otherwise
	 */
	public ArrayList<Boolean> fadesYEdges() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).fadesYEdges());
		return _returns;
	}

	/**
	 * Define whether the vertical edges should be faded when this view is
	 * scrolled vertically.
	 * 
	 * @param verticalFadingEdgeEnabled
	 *            true if the vertical edges should be faded when the view is
	 *            scrolled vertically
	 * @return self
	 */
	public self fadesYEdges(boolean verticalFadingEdgeEnabled) {
		for (X vaporView : members)
			vaporView.fadesYEdges(verticalFadingEdgeEnabled);
		return (self) this;

	}

	/**
	 * Returns the size of the vertical faded edges used to indicate that more
	 * content in this view is visible.
	 * 
	 * @return The size in pixels of the vertical faded edge or 0 if vertical
	 *         faded edges are not enabled for this view.
	 */
	public ArrayList<Integer> yFadeEdge() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).yFadeEdge());
		return _returns;
	}

	/**
	 * Return the underlying standard Android View
	 * 
	 * @return the underlying standard Android View
	 */
	public ArrayList<T> view() {
		int _size = this.members.size();
		ArrayList<T> _returns = new ArrayList<T>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).view());
		return _returns;
	}

	/**
	 * Returns the visibility status for this view.
	 * 
	 * @return One of VISIBLE, INVISIBLE, or GONE.
	 */
	public ArrayList<Integer> viz() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).viz());
		return _returns;
	}

	/**
	 * Set the enabled state of this view.
	 * 
	 * @param visibility
	 *            One of VISIBLE, INVISIBLE, or GONE.
	 * @return self
	 */
	public self viz(int visibility) {
		for (X vaporView : members)
			vaporView.viz(visibility);
		return (self) this;

	}

	/**
	 * Indicate whether the vertical scrollbar should be drawn or not. The
	 * scrollbar is not drawn by default.
	 * 
	 * @return true if the vertical scrollbar should be painted, false otherwise
	 */
	public ArrayList<Boolean> yScrolls() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).yScrolls());
		return _returns;
	}

	/**
	 * Define whether the vertical scrollbar should be drawn or not.
	 * 
	 * @param verticalScrollBarEnabled
	 *            true if the vertical scrollbar should be painted
	 * @return self
	 */
	public self yScrolls(boolean verticalScrollBarEnabled) {
		for (X vaporView : members)
			vaporView.yScrolls(verticalScrollBarEnabled);
		return (self) this;

	}

	/**
	 * Returns the vertical scrollbar position
	 * 
	 * @return The position where the vertical scroll bar will show, if
	 *         applicable.
	 */
	public ArrayList<Integer> yScrollPos() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).yScrollPos());
		return _returns;
	}

	/**
	 * Set the position of the vertical scroll bar.
	 * 
	 * @param position
	 *            Where the vertical scroll bar should be positioned.
	 * @return self
	 */
	public self yScrollPos(int position) {
		for (X vaporView : members)
			vaporView.yScrollPos(position);
		return (self) this;

	}

	/**
	 * return the width of the your view.
	 * 
	 * @return The width of your view, in pixels.
	 */
	public final ArrayList<Integer> width() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).width());
		return _returns;
	}

	/**
	 * Returns true if this view is in a window that currently has window focus.
	 * 
	 * @return True if this view is in a window that currently has window focus.
	 */
	public ArrayList<Boolean> winFocused() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).winFocused());
		return _returns;
	}

	/**
	 * Fluent equivalent Vapor method for invoking
	 * onWindowFocusChanged(boolean), called when the window containing this
	 * view gains or loses focus. Note that this is separate from view focus: to
	 * receive key events, both your view and its window must have focus.
	 * 
	 * @param hasWindowFocus
	 *            True if the window containing this view now has focus, false
	 *            otherwise.
	 * @return self
	 */
	public self winFocusChanged(boolean hasWindowFocus) {
		for (X vaporView : members)
			vaporView.winFocusChanged(hasWindowFocus);
		return (self) this;

	}

	/**
	 * Returns the current system UI visibility that is currently set for the
	 * entire window.
	 * 
	 * @return
	 */
	public ArrayList<Integer> winSysViz() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).winSysViz());
		return _returns;
	}

	/**
	 * Fluent equivalent Vapor method for invoking
	 * onWindowSystemUiVisibilityChanged(int)
	 * 
	 * @param visible
	 * @return
	 */
	public self winSysVizChanged(int visible) {
		for (X vaporView : members)
			vaporView.winSysVizChanged(visible);
		return (self) this;

	}

	/**
	 * Returns the current visibility of the window this view is attached to
	 * (either GONE, INVISIBLE, or VISIBLE).
	 * 
	 * @return Returns the current visibility of the view's window.
	 */
	public ArrayList<Integer> winViz() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).winViz());
		return _returns;
	}

	/**
	 * Retrieve the overall visible display size in which the window this view
	 * is attached to has been positioned in.
	 * 
	 * @param outRect
	 *            Filled in with the visible display frame. If the view is not
	 *            attached to a window, this is simply the raw display size.
	 * @return self
	 */
	public self winVizFrame(Rect outRect) {
		for (X vaporView : members)
			vaporView.winVizFrame(outRect);
		return (self) this;

	}

	/**
	 * The visual x position of this view, in pixels.
	 * 
	 * @return The visual x position of this view, in pixels.
	 */
	public ArrayList<Float> x() {
		int _size = this.members.size();
		ArrayList<Float> _returns = new ArrayList<Float>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).x());
		return _returns;
	}

	/**
	 * Sets the visual x position of this view, in pixels.
	 * 
	 * @param x
	 *            The visual x position of this view, in pixels.
	 * @return self
	 */
	public self x(float x) {
		for (X vaporView : members)
			vaporView.x(x);
		return (self) this;

	}

	/**
	 * The visual y position of this view, in pixels.
	 * 
	 * @return The visual y position of this view, in pixels.
	 */
	public ArrayList<Float> y() {
		int _size = this.members.size();
		ArrayList<Float> _returns = new ArrayList<Float>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).y());
		return _returns;
	}

	/**
	 * Sets the visual y position of this view, in pixels.
	 * 
	 * @param y
	 *            The visual y position of this view, in pixels.
	 * @return self
	 */
	public self y(float y) {
		for (X vaporView : members)
			vaporView.y(y);
		return (self) this;

	}

	/**
	 * Gets the distance along the Z axis from the camera to this view.
	 * 
	 * @return The distance along the Z axis.
	 */
	public ArrayList<Float> z() {
		int _size = this.members.size();
		ArrayList<Float> _returns = new ArrayList<Float>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).z());
		return _returns;
	}

	/**
	 * Sets the distance along the Z axis (orthogonal to the X/Y plane on which
	 * views are drawn) from the camera to this view.
	 * 
	 * @param z
	 *            The distance in "depth pixels", if negative the opposite value
	 *            is used
	 * @return self
	 */
	public self z(float z) {
		for (X vaporView : members)
			vaporView.z(z);
		return (self) this;

	}

}