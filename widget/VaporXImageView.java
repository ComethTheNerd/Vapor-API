/*	Vapor API Terms and Conditions
 *
 *  - You MAY NOT
 *  	- attempt to claim ownership of, or pass off the Vapor source code and materials as your own work unless:
 *
 *  		- used as constituent component in an Android application that you intend to release and/or profit from
 *
 *		- use or redistribute the Vapor source code and materials without explicit attribution to the owning parties
 *
 *  	- advertise Vapor in a misleading, inappropriate or offensive fashion
 *
 * - Indemnity
 * 		You agree to indemnify and hold harmless the authors of the Software and any contributors for any direct, indirect, 
 * 		incidental, or consequential third-party claims, actions or suits, as well as any related expenses, liabilities, damages, 
 * 		settlements or fees arising from your use or misuse of the Software, or a violation of any terms of this license.
 *  
 *  - DISCLAIMER OF WARRANTY
 *  	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, 
 *		WARRANTIES OF QUALITY, PERFORMANCE, NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
 *  
 *  - LIMITATIONS OF LIABILITY
 *  	YOU ASSUME ALL RISK ASSOCIATED WITH THE INSTALLATION AND USE OF THE SOFTWARE. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT 
 * 		HOLDERS OF THE SOFTWARE BE LIABLE FOR CLAIMS, DAMAGES OR OTHER LIABILITY ARISING FROM, OUT OF, OR IN CONNECTION WITH THE 
 *		SOFTWARE. LICENSE HOLDERS ARE SOLELY RESPONSIBLE FOR DETERMINING THE APPROPRIATENESS OF USE AND ASSUME ALL RISKS ASSOCIATED 
 *		WITH ITS USE, INCLUDING BUT NOT LIMITED TO THE RISKS OF PROGRAM ERRORS, DAMAGE TO EQUIPMENT, LOSS OF DATA OR SOFTWARE PROGRAMS, 
 *		OR UNAVAILABILITY OR INTERRUPTION OF OPERATIONS.
 *  
 *  Â© Darius Hodaei. License Version 1.1. Last Updated 30/06/2013.
*/

/*This file has been autogenerated by the Vapid Tool v1.0 @ 22/12/2012 22:43:13*/
package vapor.widget;

import java.util.ArrayList;

import vapor.view.VaporXView;
import android.graphics.Bitmap;
import android.graphics.ColorFilter;
import android.graphics.Matrix;
import android.graphics.PorterDuff;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.widget.ImageView;

/**
 * Fluent variadic Vapor companion to ImageView, a view that displays an
 * arbitrary image, such as an icon. The ImageView class can load images from
 * various sources (such as resources or content providers), takes care of
 * computing its measurement from the image so that it can be used in any layout
 * manager, and provides various display options such as scaling and tinting.
 * 
 * @author Darius H (darius@vapor-api.com)
 * @since 1.0
 * @param <T>
 *            A standard Android type derived from ImageView
 * @param <X>
 *            A Vapor type derived from VaporImageView
 * @param <self>
 *            A recursively defined type that provides information for fluent
 *            method invocation
 */
public class VaporXImageView<T extends ImageView, X extends VaporImageView<T, ?>, self extends VaporXImageView<T, X, self>>
		extends VaporXView<T, X, self> {

	public VaporXImageView(Integer... ids) {
		super(ids);
	}

	public VaporXImageView(T... imageViews) {
		super(imageViews);
	}

	public VaporXImageView(X... vaporImageViews) {
		super(vaporImageViews);
	}

	public VaporXImageView(VaporXImageView<T, X, ?>... vaporXImageViews) {
		super(vaporXImageViews);
	}

	public VaporXImageView(Object... imageViewItems) {
		super(imageViewItems);
	}

	/**
	 * True when ImageView is adjusting its bounds to preserve the aspect ratio
	 * of its drawable
	 * 
	 * @return whether to adjust the bounds of this view to preserve the
	 *         original aspect ratio of the drawable
	 */
	public ArrayList<Boolean> adjustBounds() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).adjustBounds());
		return _returns;
	}

	/**
	 * Set this to true if you want the ImageView to adjust its bounds to
	 * preserve the aspect ratio of its drawable.
	 * 
	 * @param adjustViewBounds
	 *            Whether to adjust the bounds of this view to presrve the
	 *            original aspect ratio of the drawable
	 * @return self
	 */
	public self adjustBounds(boolean adjustViewBounds) {
		for (X vaporView : members)
			vaporView.adjustBounds(adjustViewBounds);
		return (self) this;

	}

	/**
	 * Returns the alpha that will be applied to the drawable of this ImageView.
	 * 
	 * @return the alpha that will be applied to the drawable of this ImageView
	 */
	@Override
	public ArrayList<Float> alpha() {
		int _size = this.members.size();
		ArrayList<Float> _returns = new ArrayList<Float>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).alpha());
		return _returns;
	}

	public self alpha(float imageAlpha) {
		for (X vaporView : members)
			vaporView.alpha(imageAlpha);
		return (self) this;

	}

	/**
	 * Set the offset of the widget's text baseline from the widget's top
	 * boundary. This value is overridden by the baselineAlignBottom(boolean)
	 * property.
	 * 
	 * @param baseline
	 * @return self
	 */
	public self baseline(int baseline) {
		for (X vaporView : members)
			vaporView.baseline(baseline);
		return (self) this;

	}

	/**
	 * Return whether this view's baseline will be considered the bottom of the
	 * view.
	 * 
	 * @return true if this view's baseline will be considered the bottom of the
	 *         view
	 */
	public ArrayList<Boolean> baselineAlignBottom() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).baselineAlignBottom());
		return _returns;
	}

	/**
	 * Set whether to set the baseline of this view to the bottom of the view.
	 * Setting this value overrides any calls to baseline(int).
	 * 
	 * @param aligned
	 *            If true, the image view will be baseline aligned with based on
	 *            its bottom edge.
	 * @return self
	 */
	public self baselineAlignBottom(boolean aligned) {
		for (X vaporView : members)
			vaporView.baselineAlignBottom(aligned);
		return (self) this;

	}

	/**
	 * 
	 * @return self
	 */
	public final self clearFilter() {
		for (X vaporView : members)
			vaporView.clearFilter();
		return (self) this;
	}

	/**
	 * Return whether this ImageView crops to padding.
	 * 
	 * @return whether this ImageView crops to padding
	 */
	public ArrayList<Boolean> cropToPad() {
		int _size = this.members.size();
		ArrayList<Boolean> _returns = new ArrayList<Boolean>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).cropToPad());
		return _returns;
	}

	/**
	 * Sets whether this ImageView will crop to padding.
	 * 
	 * @param cropToPadding
	 *            whether this ImageView will crop to padding
	 * @return self
	 */
	public self cropToPad(boolean cropToPadding) {
		for (X vaporView : members)
			vaporView.cropToPad(cropToPadding);
		return (self) this;

	}

	/**
	 * Fluent equivalent Vapor method for invoking onCreateDrawableState(int),
	 * which generates the new Drawable state for this view. This is called by
	 * the view system when the cached Drawable state is determined to be
	 * invalid.
	 * 
	 * @param extraSpace
	 *            if non-zero, this is the number of extra entries you would
	 *            like in the returned array in which you can place your own
	 *            states.
	 * @return Returns an array holding the current Drawable state of the view.
	 */
	public ArrayList<Integer[]> drawState(int extraSpace) {
		int _size = this.members.size();
		ArrayList<Integer[]> _returns = new ArrayList<Integer[]>(_size);
		for (int _index = 0; _index < _size; _index++) {

			// We cannot implicitly convert int[] to Integer[], so we do it
			// manually
			int[] values = this.members.get(_index).drawState(extraSpace);
			Integer[] _values = new Integer[values.length];

			for (int _i = 0; _i < values.length; _i++)
				_values[_i] = Integer.valueOf(values[_i]);

			_returns.add(_values);
		}
		return _returns;
	}

	/**
	 * Returns the active color filter for this ImageView.
	 * 
	 * @return the active color filter for this ImageView+
	 */
	public ArrayList<ColorFilter> filter() {
		int _size = this.members.size();
		ArrayList<ColorFilter> _returns = new ArrayList<ColorFilter>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).filter());
		return _returns;
	}

	/**
	 * Set a tinting option for the image. Assumes SRC_ATOP blending mode.
	 * 
	 * @param color
	 *            Color tint to apply.
	 * @return self
	 */
	public final self filter(int color) {
		for (X vaporView : members)
			vaporView.filter(color);
		return (self) this;
	}

	/**
	 * Apply an arbitrary colorfilter to the image.
	 * 
	 * @param colorFilter
	 *            the colorfilter to apply (may be null)
	 * @return self
	 */
	public self filter(ColorFilter colorFilter) {
		for (X vaporView : members)
			vaporView.filter(colorFilter);
		return (self) this;

	}

	/**
	 * Set a tinting option for the image.
	 * 
	 * @param color
	 *            Color tint to apply.
	 * @param porterDuffMode
	 *            How to apply the color. The standard mode is SRC_ATOP
	 * @return self
	 */
	public final self filter(int color, PorterDuff.Mode porterDuffMode) {
		for (X vaporView : members)
			vaporView.filter(color, porterDuffMode);
		return (self) this;
	}

	/**
	 * Return the view's drawable, or null if no drawable has been assigned.
	 * 
	 * @return the view's drawable, or null if no drawable has been assigned.
	 */
	public ArrayList<Drawable> img() {
		int _size = this.members.size();
		ArrayList<Drawable> _returns = new ArrayList<Drawable>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).img());
		return _returns;
	}

	/**
	 * Sets a drawable as the content of this ImageView.
	 * 
	 * @param resId
	 *            the resource identifier of the the drawable
	 * @return self
	 */
	public self img(int resId) {
		for (X vaporView : members)
			vaporView.img(resId);
		return (self) this;

	}

	/**
	 * Sets a Bitmap as the content of this ImageView.
	 * 
	 * @param bitmap
	 *            The bitmap to set
	 * @return self
	 */
	public self img(Bitmap bitmap) {
		for (X vaporView : members)
			vaporView.img(bitmap);
		return (self) this;

	}

	/**
	 * Sets a drawable as the content of this ImageView.
	 * 
	 * @param drawable
	 *            The drawable to set
	 * @return self
	 */
	public self img(Drawable drawable) {
		for (X vaporView : members)
			vaporView.img(drawable);
		return (self) this;

	}

	/**
	 * Sets the content of this ImageView to the specified Uri.
	 * 
	 * @param imageUri
	 *            The Uri of an image
	 * @return self
	 */
	public self img(Uri imageUri) {
		for (X vaporView : members)
			vaporView.img(imageUri);
		return (self) this;

	}

	/**
	 * Sets the image level, when it is constructed from a LevelListDrawable.
	 * 
	 * @param imageLevel
	 *            The new level for the image.
	 * @return self
	 */
	public self imgLevel(int imageLevel) {
		for (X vaporView : members)
			vaporView.imgLevel(imageLevel);
		return (self) this;

	}

	/**
	 * Return the view's optional matrix. This is applied to the view's drawable
	 * when it is drawn. If there is not matrix, this method will return null.
	 * Do not change this matrix in place. If you want a different matrix applied
	 * to the drawable, be sure to call setImageMatrix().
	 * 
	 * @return the view's optional matrix
	 */
	public ArrayList<Matrix> imgMatrix() {
		int _size = this.members.size();
		ArrayList<Matrix> _returns = new ArrayList<Matrix>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).imgMatrix());
		return _returns;
	}

	/**
	 * 
	 * @param imageMatrix
	 * @return self
	 */
	public self imgMatrix(Matrix imageMatrix) {
		for (X vaporView : members)
			vaporView.imgMatrix(imageMatrix);
		return (self) this;

	}

	/**
	 * 
	 * @param imageState
	 * @param merge
	 * @return self
	 */
	public self imgState(int[] imageState, boolean merge) {
		for (X vaporView : members)
			vaporView.imgState(imageState, merge);
		return (self) this;

	}

	/**
	 * The maximum height of this view.
	 * 
	 * @return The maximum height of this view
	 */
	public ArrayList<Integer> maxHeight() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).maxHeight());
		return _returns;
	}

	/**
	 * An optional argument to supply a maximum height for this view. Only valid
	 * if adjustBounds(boolean) has been set to true.
	 * 
	 * @param maxHeight
	 *            maximum height for this view
	 * @return self
	 */
	public self maxHeight(int maxHeight) {
		for (X vaporView : members)
			vaporView.maxHeight(maxHeight);
		return (self) this;

	}

	/**
	 * The maximum width of this view.
	 * 
	 * @return The maximum width of this view
	 */
	public ArrayList<Integer> maxWidth() {
		int _size = this.members.size();
		ArrayList<Integer> _returns = new ArrayList<Integer>(_size);
		for (int _index = 0; _index < _size; _index++)
			_returns.add(this.members.get(_index).maxWidth());
		return _returns;
	}

	/**
	 * An optional argument to supply a maximum width for this view. Only valid
	 * if adjustBounds(boolean) has been set to true.
	 * 
	 * @param maximum
	 *            width for this view
	 * @return self
	 */
	public self maxWidth(int maxWidth) {
		for (X vaporView : members)
			vaporView.maxWidth(maxWidth);
		return (self) this;

	}

	/**
	 * Controls how the image should be resized or moved to match the size of
	 * this ImageView.
	 * 
	 * @param scaleType
	 *            The desired scaling mode.
	 * @return self
	 */
	public self scaleType(ImageView.ScaleType scaleType) {
		for (X vaporView : members)
			vaporView.scaleType(scaleType);
		return (self) this;

	}

}